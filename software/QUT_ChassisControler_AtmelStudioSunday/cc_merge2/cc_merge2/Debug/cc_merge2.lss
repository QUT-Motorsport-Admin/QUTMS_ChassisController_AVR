
cc_merge2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800200  00000c40  00000cd4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000c40  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000097  00800204  00800204  00000cd8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000cd8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000d08  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000340  00000000  00000000  00000d48  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000038ca  00000000  00000000  00001088  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001591  00000000  00000000  00004952  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001a41  00000000  00000000  00005ee3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000a78  00000000  00000000  00007924  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000010af  00000000  00000000  0000839c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002a94  00000000  00000000  0000944b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002e0  00000000  00000000  0000bedf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
   2:	00 00       	nop
   4:	c3 c2       	rjmp	.+1414   	; 0x58c <__vector_1>
   6:	00 00       	nop
   8:	81 c2       	rjmp	.+1282   	; 0x50c <__vector_2>
   a:	00 00       	nop
   c:	88 c0       	rjmp	.+272    	; 0x11e <__bad_interrupt>
   e:	00 00       	nop
  10:	86 c0       	rjmp	.+268    	; 0x11e <__bad_interrupt>
  12:	00 00       	nop
  14:	84 c0       	rjmp	.+264    	; 0x11e <__bad_interrupt>
  16:	00 00       	nop
  18:	82 c0       	rjmp	.+260    	; 0x11e <__bad_interrupt>
  1a:	00 00       	nop
  1c:	80 c0       	rjmp	.+256    	; 0x11e <__bad_interrupt>
  1e:	00 00       	nop
  20:	7e c0       	rjmp	.+252    	; 0x11e <__bad_interrupt>
  22:	00 00       	nop
  24:	f3 c2       	rjmp	.+1510   	; 0x60c <__vector_9>
  26:	00 00       	nop
  28:	7a c0       	rjmp	.+244    	; 0x11e <__bad_interrupt>
  2a:	00 00       	nop
  2c:	78 c0       	rjmp	.+240    	; 0x11e <__bad_interrupt>
  2e:	00 00       	nop
  30:	76 c0       	rjmp	.+236    	; 0x11e <__bad_interrupt>
  32:	00 00       	nop
  34:	74 c0       	rjmp	.+232    	; 0x11e <__bad_interrupt>
  36:	00 00       	nop
  38:	72 c0       	rjmp	.+228    	; 0x11e <__bad_interrupt>
  3a:	00 00       	nop
  3c:	70 c0       	rjmp	.+224    	; 0x11e <__bad_interrupt>
  3e:	00 00       	nop
  40:	6e c0       	rjmp	.+220    	; 0x11e <__bad_interrupt>
  42:	00 00       	nop
  44:	59 c2       	rjmp	.+1202   	; 0x4f8 <__vector_17>
  46:	00 00       	nop
  48:	6a c0       	rjmp	.+212    	; 0x11e <__bad_interrupt>
  4a:	00 00       	nop
  4c:	68 c0       	rjmp	.+208    	; 0x11e <__bad_interrupt>
  4e:	00 00       	nop
  50:	66 c0       	rjmp	.+204    	; 0x11e <__bad_interrupt>
  52:	00 00       	nop
  54:	2a c2       	rjmp	.+1108   	; 0x4aa <__vector_21>
  56:	00 00       	nop
  58:	62 c0       	rjmp	.+196    	; 0x11e <__bad_interrupt>
  5a:	00 00       	nop
  5c:	60 c0       	rjmp	.+192    	; 0x11e <__bad_interrupt>
  5e:	00 00       	nop
  60:	5e c0       	rjmp	.+188    	; 0x11e <__bad_interrupt>
  62:	00 00       	nop
  64:	dc c4       	rjmp	.+2488   	; 0xa1e <__vector_25>
  66:	00 00       	nop
  68:	38 c5       	rjmp	.+2672   	; 0xada <__vector_26>
  6a:	00 00       	nop
  6c:	58 c0       	rjmp	.+176    	; 0x11e <__bad_interrupt>
  6e:	00 00       	nop
  70:	56 c0       	rjmp	.+172    	; 0x11e <__bad_interrupt>
  72:	00 00       	nop
  74:	54 c0       	rjmp	.+168    	; 0x11e <__bad_interrupt>
  76:	00 00       	nop
  78:	52 c0       	rjmp	.+164    	; 0x11e <__bad_interrupt>
  7a:	00 00       	nop
  7c:	50 c0       	rjmp	.+160    	; 0x11e <__bad_interrupt>
  7e:	00 00       	nop
  80:	4e c0       	rjmp	.+156    	; 0x11e <__bad_interrupt>
  82:	00 00       	nop
  84:	4c c0       	rjmp	.+152    	; 0x11e <__bad_interrupt>
  86:	00 00       	nop
  88:	4a c0       	rjmp	.+148    	; 0x11e <__bad_interrupt>
  8a:	00 00       	nop
  8c:	48 c0       	rjmp	.+144    	; 0x11e <__bad_interrupt>
  8e:	00 00       	nop
  90:	f5 c4       	rjmp	.+2538   	; 0xa7c <__vector_36>
  92:	00 00       	nop
  94:	50 c5       	rjmp	.+2720   	; 0xb36 <__vector_37>
  96:	00 00       	nop
  98:	42 c0       	rjmp	.+132    	; 0x11e <__bad_interrupt>
  9a:	00 00       	nop
  9c:	40 c0       	rjmp	.+128    	; 0x11e <__bad_interrupt>
  9e:	00 00       	nop
  a0:	3e c0       	rjmp	.+124    	; 0x11e <__bad_interrupt>
  a2:	00 00       	nop
  a4:	3c c0       	rjmp	.+120    	; 0x11e <__bad_interrupt>
  a6:	00 00       	nop
  a8:	3a c0       	rjmp	.+116    	; 0x11e <__bad_interrupt>
  aa:	00 00       	nop
  ac:	38 c0       	rjmp	.+112    	; 0x11e <__bad_interrupt>
  ae:	00 00       	nop
  b0:	36 c0       	rjmp	.+108    	; 0x11e <__bad_interrupt>
  b2:	00 00       	nop
  b4:	34 c0       	rjmp	.+104    	; 0x11e <__bad_interrupt>
  b6:	00 00       	nop
  b8:	32 c0       	rjmp	.+100    	; 0x11e <__bad_interrupt>
  ba:	00 00       	nop
  bc:	30 c0       	rjmp	.+96     	; 0x11e <__bad_interrupt>
  be:	00 00       	nop
  c0:	2e c0       	rjmp	.+92     	; 0x11e <__bad_interrupt>
  c2:	00 00       	nop
  c4:	2c c0       	rjmp	.+88     	; 0x11e <__bad_interrupt>
  c6:	00 00       	nop
  c8:	2a c0       	rjmp	.+84     	; 0x11e <__bad_interrupt>
  ca:	00 00       	nop
  cc:	28 c0       	rjmp	.+80     	; 0x11e <__bad_interrupt>
  ce:	00 00       	nop
  d0:	26 c0       	rjmp	.+76     	; 0x11e <__bad_interrupt>
  d2:	00 00       	nop
  d4:	24 c0       	rjmp	.+72     	; 0x11e <__bad_interrupt>
  d6:	00 00       	nop
  d8:	22 c0       	rjmp	.+68     	; 0x11e <__bad_interrupt>
  da:	00 00       	nop
  dc:	20 c0       	rjmp	.+64     	; 0x11e <__bad_interrupt>
  de:	00 00       	nop
  e0:	1e c0       	rjmp	.+60     	; 0x11e <__bad_interrupt>
	...

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61

000000f0 <__do_copy_data>:
  f0:	12 e0       	ldi	r17, 0x02	; 2
  f2:	a0 e0       	ldi	r26, 0x00	; 0
  f4:	b2 e0       	ldi	r27, 0x02	; 2
  f6:	e0 e4       	ldi	r30, 0x40	; 64
  f8:	fc e0       	ldi	r31, 0x0C	; 12
  fa:	00 e0       	ldi	r16, 0x00	; 0
  fc:	0b bf       	out	0x3b, r16	; 59
  fe:	02 c0       	rjmp	.+4      	; 0x104 <__do_copy_data+0x14>
 100:	07 90       	elpm	r0, Z+
 102:	0d 92       	st	X+, r0
 104:	a4 30       	cpi	r26, 0x04	; 4
 106:	b1 07       	cpc	r27, r17
 108:	d9 f7       	brne	.-10     	; 0x100 <__do_copy_data+0x10>

0000010a <__do_clear_bss>:
 10a:	22 e0       	ldi	r18, 0x02	; 2
 10c:	a4 e0       	ldi	r26, 0x04	; 4
 10e:	b2 e0       	ldi	r27, 0x02	; 2
 110:	01 c0       	rjmp	.+2      	; 0x114 <.do_clear_bss_start>

00000112 <.do_clear_bss_loop>:
 112:	1d 92       	st	X+, r1

00000114 <.do_clear_bss_start>:
 114:	ab 39       	cpi	r26, 0x9B	; 155
 116:	b2 07       	cpc	r27, r18
 118:	e1 f7       	brne	.-8      	; 0x112 <.do_clear_bss_loop>
 11a:	25 d1       	rcall	.+586    	; 0x366 <main>
 11c:	8f c5       	rjmp	.+2846   	; 0xc3c <_exit>

0000011e <__bad_interrupt>:
 11e:	70 cf       	rjmp	.-288    	; 0x0 <__vectors>

00000120 <a2d_10bitCh>:
// starts conversion, waits until conversion is done, and returns result
// modded for mega1280 by Ant
unsigned short a2d_10bitCh(unsigned char ch)
{
	// set channel
	ADMUX &= ADC_MUX_MASK;	
 120:	ec e7       	ldi	r30, 0x7C	; 124
 122:	f0 e0       	ldi	r31, 0x00	; 0
 124:	90 81       	ld	r25, Z
 126:	90 7e       	andi	r25, 0xE0	; 224
 128:	90 83       	st	Z, r25
	
	if (ch > 7) 
 12a:	88 30       	cpi	r24, 0x08	; 8
 12c:	60 f0       	brcs	.+24     	; 0x146 <a2d_10bitCh+0x26>
	{
		ADCSRB |= 8;
 12e:	eb e7       	ldi	r30, 0x7B	; 123
 130:	f0 e0       	ldi	r31, 0x00	; 0
 132:	90 81       	ld	r25, Z
 134:	98 60       	ori	r25, 0x08	; 8
 136:	90 83       	st	Z, r25
		ADMUX |= (ch - 8);
 138:	ec e7       	ldi	r30, 0x7C	; 124
 13a:	f0 e0       	ldi	r31, 0x00	; 0
 13c:	90 81       	ld	r25, Z
 13e:	88 50       	subi	r24, 0x08	; 8
 140:	89 2b       	or	r24, r25
 142:	80 83       	st	Z, r24
 144:	0a c0       	rjmp	.+20     	; 0x15a <a2d_10bitCh+0x3a>
	}
	else
	{
		ADCSRB &= 247;
 146:	eb e7       	ldi	r30, 0x7B	; 123
 148:	f0 e0       	ldi	r31, 0x00	; 0
 14a:	90 81       	ld	r25, Z
 14c:	97 7f       	andi	r25, 0xF7	; 247
 14e:	90 83       	st	Z, r25
		ADMUX |= ch;
 150:	ec e7       	ldi	r30, 0x7C	; 124
 152:	f0 e0       	ldi	r31, 0x00	; 0
 154:	90 81       	ld	r25, Z
 156:	89 2b       	or	r24, r25
 158:	80 83       	st	Z, r24
	}
	
	// ADMUX |= ch;	//comment out this line when using on 16ch parts

	// start conversion
	ADCSRA |= (1<<ADSC);
 15a:	ea e7       	ldi	r30, 0x7A	; 122
 15c:	f0 e0       	ldi	r31, 0x00	; 0
 15e:	80 81       	ld	r24, Z
 160:	80 64       	ori	r24, 0x40	; 64
 162:	80 83       	st	Z, r24

	while(ADCSRA & (1 << ADSC)) {} // wait until conversion complete 
 164:	80 81       	ld	r24, Z
 166:	86 fd       	sbrc	r24, 6
 168:	fd cf       	rjmp	.-6      	; 0x164 <a2d_10bitCh+0x44>

	return ADC;                // read ADC (full 10 bits);
 16a:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 16e:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
	// return (8 << ADCH)|(ADCL); // read ADC (full 10 bits);
    // return ADCL;                // read ADC (first 8 bits)
}
 172:	08 95       	ret

00000174 <CAN_send>:
        sendingID|                  // Sending ID, ( First 8 bits, define the device to send to)
        ((uint32_t)type<<18)|       // What sort of command to send
        ((uint32_t)address<<13)|    // Specific address
        status                      // SubID?
    );
}
 174:	8f 92       	push	r8
 176:	9f 92       	push	r9
 178:	af 92       	push	r10
 17a:	bf 92       	push	r11
 17c:	cf 92       	push	r12
 17e:	df 92       	push	r13
 180:	ef 92       	push	r14
 182:	ff 92       	push	r15
 184:	0f 93       	push	r16
 186:	1f 93       	push	r17
 188:	cf 93       	push	r28
 18a:	df 93       	push	r29
 18c:	c8 2f       	mov	r28, r24
 18e:	d6 2f       	mov	r29, r22
 190:	6a 01       	movw	r12, r20
 192:	48 01       	movw	r8, r16
 194:	59 01       	movw	r10, r18
 196:	90 d3       	rcall	.+1824   	; 0x8b8 <MCP2515_findFreeTxBuffer>
 198:	85 01       	movw	r16, r10
 19a:	74 01       	movw	r14, r8
 19c:	96 01       	movw	r18, r12
 19e:	4d 2f       	mov	r20, r29
 1a0:	68 2f       	mov	r22, r24
 1a2:	8c 2f       	mov	r24, r28
 1a4:	a2 d3       	rcall	.+1860   	; 0x8ea <MCP2515_TX>
 1a6:	df 91       	pop	r29
 1a8:	cf 91       	pop	r28
 1aa:	1f 91       	pop	r17
 1ac:	0f 91       	pop	r16
 1ae:	ff 90       	pop	r15
 1b0:	ef 90       	pop	r14
 1b2:	df 90       	pop	r13
 1b4:	cf 90       	pop	r12
 1b6:	bf 90       	pop	r11
 1b8:	af 90       	pop	r10
 1ba:	9f 90       	pop	r9
 1bc:	8f 90       	pop	r8
 1be:	08 95       	ret

000001c0 <CAN_pull_packet>:

// Serves as a wrapper for the MCP2515_PullCanPacket(..) in MCP2515.h - For more info refer to that.
void CAN_pull_packet(uint8_t CANbus, uint8_t* numBytes, uint8_t* data, uint32_t* ID) {
 1c0:	af 92       	push	r10
 1c2:	bf 92       	push	r11
 1c4:	cf 92       	push	r12
 1c6:	df 92       	push	r13
 1c8:	ef 92       	push	r14
 1ca:	ff 92       	push	r15
 1cc:	0f 93       	push	r16
 1ce:	1f 93       	push	r17
 1d0:	cf 93       	push	r28
 1d2:	c8 2f       	mov	r28, r24
 1d4:	7b 01       	movw	r14, r22
 1d6:	6a 01       	movw	r12, r20
 1d8:	59 01       	movw	r10, r18
	// Receive the status of the buffers RXB0 and RXB1
	uint8_t status = MCP2515_check_receive_status(CANbus);
 1da:	04 d4       	rcall	.+2056   	; 0x9e4 <MCP2515_check_receive_status>
	// Check which receive buffer contains the data (or if both contain) by checking bits 7:6
	switch(status>>6) {
 1dc:	82 95       	swap	r24
 1de:	86 95       	lsr	r24
 1e0:	86 95       	lsr	r24
 1e2:	83 70       	andi	r24, 0x03	; 3
 1e4:	82 30       	cpi	r24, 0x02	; 2
 1e6:	59 f0       	breq	.+22     	; 0x1fe <CAN_pull_packet+0x3e>
 1e8:	83 30       	cpi	r24, 0x03	; 3
 1ea:	81 f0       	breq	.+32     	; 0x20c <CAN_pull_packet+0x4c>
 1ec:	81 30       	cpi	r24, 0x01	; 1
 1ee:	c9 f4       	brne	.+50     	; 0x222 <CAN_pull_packet+0x62>
		case 1:	// Message in RXB0
			MCP2515_PullCanPacket(CANbus, MCP2515_RXB0SIDH, numBytes, data, ID);
 1f0:	85 01       	movw	r16, r10
 1f2:	96 01       	movw	r18, r12
 1f4:	a7 01       	movw	r20, r14
 1f6:	61 e6       	ldi	r22, 0x61	; 97
 1f8:	8c 2f       	mov	r24, r28
 1fa:	cb d2       	rcall	.+1430   	; 0x792 <MCP2515_PullCanPacket>
			break;
 1fc:	12 c0       	rjmp	.+36     	; 0x222 <CAN_pull_packet+0x62>
		case 2: // Message in RXB1
			MCP2515_PullCanPacket(CANbus, MCP2515_RXB0SIDH, numBytes, data, ID);
 1fe:	85 01       	movw	r16, r10
 200:	96 01       	movw	r18, r12
 202:	a7 01       	movw	r20, r14
 204:	61 e6       	ldi	r22, 0x61	; 97
 206:	8c 2f       	mov	r24, r28
 208:	c4 d2       	rcall	.+1416   	; 0x792 <MCP2515_PullCanPacket>
			break;
 20a:	0b c0       	rjmp	.+22     	; 0x222 <CAN_pull_packet+0x62>
		case 3: // Message in both buffers
			MCP2515_PullCanPacket(CANbus, MCP2515_RXB0SIDH, numBytes, data, ID);
 20c:	85 01       	movw	r16, r10
 20e:	96 01       	movw	r18, r12
 210:	a7 01       	movw	r20, r14
 212:	61 e6       	ldi	r22, 0x61	; 97
 214:	8c 2f       	mov	r24, r28
 216:	bd d2       	rcall	.+1402   	; 0x792 <MCP2515_PullCanPacket>
			MCP2515_PullCanPacket(CANbus, MCP2515_RXB0SIDH, numBytes, data, ID);
 218:	96 01       	movw	r18, r12
 21a:	a7 01       	movw	r20, r14
 21c:	61 e6       	ldi	r22, 0x61	; 97
 21e:	8c 2f       	mov	r24, r28
 220:	b8 d2       	rcall	.+1392   	; 0x792 <MCP2515_PullCanPacket>
			break;
		default:
			break;
	}
}
 222:	cf 91       	pop	r28
 224:	1f 91       	pop	r17
 226:	0f 91       	pop	r16
 228:	ff 90       	pop	r15
 22a:	ef 90       	pop	r14
 22c:	df 90       	pop	r13
 22e:	cf 90       	pop	r12
 230:	bf 90       	pop	r11
 232:	af 90       	pop	r10
 234:	08 95       	ret

00000236 <external_interrupt_init>:
 * 
 */
void external_interrupt_init()
{
	//INT1 for CAN1, INT0 for CAN2, PCINT7 for CAN3
	EICRA |= (2<<ISC00)|(2<<ISC10);
 236:	e9 e6       	ldi	r30, 0x69	; 105
 238:	f0 e0       	ldi	r31, 0x00	; 0
 23a:	80 81       	ld	r24, Z
 23c:	8a 60       	ori	r24, 0x0A	; 10
 23e:	80 83       	st	Z, r24
	EIMSK  = (1<<INT0) | (1<<INT1);
 240:	83 e0       	ldi	r24, 0x03	; 3
 242:	8d bb       	out	0x1d, r24	; 29
	//Enable interrupts for PCINT7:0
	PCICR  = (1<<PCIE0)|(0<<PCIE1);
 244:	81 e0       	ldi	r24, 0x01	; 1
 246:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__TEXT_REGION_LENGTH__+0x7e0068>
	//CAN C interrupt
	PCMSK0 = (1<<PCINT7);
 24a:	80 e8       	ldi	r24, 0x80	; 128
 24c:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <__TEXT_REGION_LENGTH__+0x7e006b>
 250:	08 95       	ret

00000252 <io_init>:
 * 
 */
void io_init()
{
	//pins 8, 9 and 14 for MCP2515_STB high so the things respond (PE6, PE7, PH2)
	DDRE  = 0b11000010;		//PE0 = RS232 RX1; PE1 = RS232 TX1;  PE6 = STB_CAN1; PE7 = STB_CAN2;
 252:	82 ec       	ldi	r24, 0xC2	; 194
 254:	8d b9       	out	0x0d, r24	; 13
	PORTE = 0b00000000;		
 256:	1e b8       	out	0x0e, r1	; 14
	DDRH  = 0b00000111;		//PH0 = CS_CAN1; PH1 = CS_CAN2; PH2 = STB_CAN3
 258:	87 e0       	ldi	r24, 0x07	; 7
 25a:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <__TEXT_REGION_LENGTH__+0x7e0101>
	PORTH = 0b00000011;		//CS_CAN1 high; CS_CAN2 high;
 25e:	83 e0       	ldi	r24, 0x03	; 3
 260:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x7e0102>
	//pins 12, 13, 19 for the CS for each MCP2515 PH0, PH1, PB0)

	//pin 21 for MOSI, pin 20  for SCK (PB2, PB1)
	DDRB  = 0b01100111;		//PB0 = CS_CAN3; PB1 = SCK; PB2 = MOSI; PB3 = MISO; PB5 = High drive A; PB6 = Low drive A; PB7 = CAN3_INT; 
 264:	87 e6       	ldi	r24, 0x67	; 103
 266:	84 b9       	out	0x04, r24	; 4
	PORTB = 0b00000001;		//set CS_CAN3 high;
 268:	81 e0       	ldi	r24, 0x01	; 1
 26a:	85 b9       	out	0x05, r24	; 5
	
	DDRL  = 0b00011000;		//PB3 = High drive B; PB4 = Low Drive B;
 26c:	98 e1       	ldi	r25, 0x18	; 24
 26e:	90 93 0a 01 	sts	0x010A, r25	; 0x80010a <__TEXT_REGION_LENGTH__+0x7e010a>
	PORTL = 0b00000000;
 272:	10 92 0b 01 	sts	0x010B, r1	; 0x80010b <__TEXT_REGION_LENGTH__+0x7e010b>
	
	DDRD  = 0b11001000;		//PD0 = CAN2_INT; PD1 = CAN1_INT; PD2 = RS232 RX2; PD3 = RS232 TX2; PD6 = CAN1_TXPIN; PD7 = CAN2_TXPIN;
 276:	88 ec       	ldi	r24, 0xC8	; 200
 278:	8a b9       	out	0x0a, r24	; 10
	DDRD  = 0b00000000;
 27a:	1a b8       	out	0x0a, r1	; 10
	
	DDRC  = 0b00001000;		//PC3 = CAN3_TXPIN;
 27c:	88 e0       	ldi	r24, 0x08	; 8
 27e:	87 b9       	out	0x07, r24	; 7
	PORTC = 0b00000000;
 280:	18 b8       	out	0x08, r1	; 8
	
	DDRJ  = 0b00000000;		//PORTJ is used for digital input;
 282:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <__TEXT_REGION_LENGTH__+0x7e0104>
	PORTJ |= 64;			//turn the pull-ups on for digital inputs
 286:	e5 e0       	ldi	r30, 0x05	; 5
 288:	f1 e0       	ldi	r31, 0x01	; 1
 28a:	80 81       	ld	r24, Z
 28c:	80 64       	ori	r24, 0x40	; 64
 28e:	80 83       	st	Z, r24
	
	DDRA  = 0b00011000;		//PA3 = ENABLE_B; PA4 = ENABLE_A; PA1 = dig input; PA2 = dig input;
 290:	91 b9       	out	0x01, r25	; 1
	PORTA = 0b00010000;		
 292:	80 e1       	ldi	r24, 0x10	; 16
 294:	82 b9       	out	0x02, r24	; 2

	DDRK  = 0b00100000;		//PK5 = debugging LED;
 296:	80 e2       	ldi	r24, 0x20	; 32
 298:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <__TEXT_REGION_LENGTH__+0x7e0107>
	// PORTK = 0b00100000;
	
	// Enable external interrupts in order for the CAN bus to communicate with us
	external_interrupt_init();
 29c:	cc cf       	rjmp	.-104    	; 0x236 <external_interrupt_init>
 29e:	08 95       	ret

000002a0 <firmware_init>:
 * @brief Set up all devices in the ATmega and MCP2515. Initiates structs to hold data from other devices
 * 
 */
void firmware_init()
{
	io_init();
 2a0:	d8 df       	rcall	.-80     	; 0x252 <io_init>
	SPI_init();
 2a2:	b7 d3       	rcall	.+1902   	; 0xa12 <SPI_init>
 2a4:	80 e0       	ldi	r24, 0x00	; 0
    // // uart_init(UART_BAUD_SELECT(19200, 16UL));
    uart_init(19200);
 2a6:	9b e4       	ldi	r25, 0x4B	; 75
 2a8:	74 d4       	rcall	.+2280   	; 0xb92 <uart_init>
    //uart1_init(19200);
	//a2dInit(ADC_PRESCALE_DIV64, ADC_REFERENCE_AVCC); // Turns ON ADC
	MCP2515_init(MCP2515_CAN1);
 2aa:	81 e0       	ldi	r24, 0x01	; 1
 2ac:	4e c2       	rjmp	.+1180   	; 0x74a <MCP2515_init>
 2ae:	08 95       	ret

000002b0 <timer_init>:
 2b0:	84 b5       	in	r24, 0x24	; 36
 */
void timer_init()
{
    // http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-2549-8-bit-AVR-Microcontroller-ATmega640-1280-1281-2560-2561_datasheet.pdf
    // Set up 1Khz timer
    TCCR0A |= (1 << WGM01);                 // Setting CTC on timer0
 2b2:	82 60       	ori	r24, 0x02	; 2
 2b4:	84 bd       	out	0x24, r24	; 36
    TCCR0B |= (1 << CS01)|(1 << CS00);      // Set up 64 prescaler (16Mhz / 64)
 2b6:	85 b5       	in	r24, 0x25	; 37
 2b8:	83 60       	ori	r24, 0x03	; 3
 2ba:	85 bd       	out	0x25, r24	; 37
    OCR0A = 250;                            // (16*10^6) / (1000 * 64) assuming 16Mhz chip = 1Khz
 2bc:	8a ef       	ldi	r24, 0xFA	; 250
 2be:	87 bd       	out	0x27, r24	; 39
    TIMSK0 |= (1 << OCIE0A);                // Enable COMPA interupt
 2c0:	ee e6       	ldi	r30, 0x6E	; 110
 2c2:	f0 e0       	ldi	r31, 0x00	; 0
 2c4:	80 81       	ld	r24, Z
 2c6:	82 60       	ori	r24, 0x02	; 2
 2c8:	80 83       	st	Z, r24

    // Set up 50Hz comm timer
	TCCR1A = 0b00000000;			//
 2ca:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
	TCCR1B = 0b00001101;			// CTC mode & prescale clock by 1024
 2ce:	8d e0       	ldi	r24, 0x0D	; 13
 2d0:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	OCR1A =  15000;					// 312 gives 50Hz main comms speed
 2d4:	88 e9       	ldi	r24, 0x98	; 152
 2d6:	9a e3       	ldi	r25, 0x3A	; 58
 2d8:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 2dc:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	TIMSK1 = 0b00000010;			// Turn on compare interrupt for OCR1A
 2e0:	82 e0       	ldi	r24, 0x02	; 2
 2e2:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
 2e6:	08 95       	ret

000002e8 <UART_sendPacket>:
    testPacketArray[3] = INPUT_steeringAngle;       // Steering Angle - 1
                                                    //  -> RADIAN(x -> -0.99 < 0 < 0.99) * 100 + 100
    UART_sendPacket(testPacketArray);
}

void UART_sendPacket(uint8_t outgoingString[]) {
 2e8:	0f 93       	push	r16
 2ea:	1f 93       	push	r17
 2ec:	cf 93       	push	r28
 2ee:	df 93       	push	r29
 2f0:	8c 01       	movw	r16, r24
    uint8_t *ptr = outgoingString;
	uart_putc('D');
 2f2:	84 e4       	ldi	r24, 0x44	; 68
 2f4:	6a d4       	rcall	.+2260   	; 0xbca <uart_putc>
    while (*ptr++) {
 2f6:	e8 01       	movw	r28, r16
 2f8:	21 96       	adiw	r28, 0x01	; 1
 2fa:	f8 01       	movw	r30, r16
 2fc:	80 81       	ld	r24, Z
 2fe:	88 23       	and	r24, r24
 300:	39 f0       	breq	.+14     	; 0x310 <UART_sendPacket+0x28>
 302:	8e 01       	movw	r16, r28
        uart_putc(*ptr);
 304:	89 91       	ld	r24, Y+
 306:	61 d4       	rcall	.+2242   	; 0xbca <uart_putc>
}

void UART_sendPacket(uint8_t outgoingString[]) {
    uint8_t *ptr = outgoingString;
	uart_putc('D');
    while (*ptr++) {
 308:	f8 01       	movw	r30, r16
 30a:	80 81       	ld	r24, Z
 30c:	81 11       	cpse	r24, r1
 30e:	f9 cf       	rjmp	.-14     	; 0x302 <UART_sendPacket+0x1a>
        uart_putc(*ptr);
    }
 310:	df 91       	pop	r29
 312:	cf 91       	pop	r28
 314:	1f 91       	pop	r17
 316:	0f 91       	pop	r16
 318:	08 95       	ret

0000031a <UART_formTestPacket>:
// 	}
	
// 	for (int i = 0; i < 32; i++) uart1_putc(outgoingString[i]);
// }

void UART_formTestPacket(void) {
 31a:	cf 93       	push	r28
 31c:	df 93       	push	r29
 31e:	00 d0       	rcall	.+0      	; 0x320 <UART_formTestPacket+0x6>
 320:	00 d0       	rcall	.+0      	; 0x322 <UART_formTestPacket+0x8>
 322:	cd b7       	in	r28, 0x3d	; 61
 324:	de b7       	in	r29, 0x3e	; 62
    uint8_t testPacketArray[4];
    testPacketArray[0] = (ignitionState) | (armedState << 1) | (shutdownState << 2); // Button states - 1
 326:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <armedState>
 32a:	98 2f       	mov	r25, r24
 32c:	99 0f       	add	r25, r25
 32e:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <shutdownState>
 332:	88 0f       	add	r24, r24
 334:	88 0f       	add	r24, r24
 336:	89 2b       	or	r24, r25
 338:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <ignitionState>
 33c:	89 2b       	or	r24, r25
 33e:	89 83       	std	Y+1, r24	; 0x01
    testPacketArray[1] = INPUT_accelerationPedal;   // Throttle Pedal Percentage - 1
 340:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <INPUT_accelerationPedal>
 344:	8a 83       	std	Y+2, r24	; 0x02
    testPacketArray[2] = INPUT_brakePedal;          // Brake Pedal Percentage - 1
 346:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <__data_end>
 34a:	8b 83       	std	Y+3, r24	; 0x03
    testPacketArray[3] = INPUT_steeringAngle;       // Steering Angle - 1
 34c:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <INPUT_steeringAngle>
 350:	8c 83       	std	Y+4, r24	; 0x04
                                                    //  -> RADIAN(x -> -0.99 < 0 < 0.99) * 100 + 100
    UART_sendPacket(testPacketArray);
 352:	ce 01       	movw	r24, r28
 354:	01 96       	adiw	r24, 0x01	; 1
 356:	c8 df       	rcall	.-112    	; 0x2e8 <UART_sendPacket>
}
 358:	0f 90       	pop	r0
 35a:	0f 90       	pop	r0
 35c:	0f 90       	pop	r0
 35e:	0f 90       	pop	r0
 360:	df 91       	pop	r29
 362:	cf 91       	pop	r28
 364:	08 95       	ret

00000366 <main>:
volatile uint8_t testArm = 0;

int main(void) {    

    // Set Up
    firmware_init();
 366:	9c df       	rcall	.-200    	; 0x2a0 <firmware_init>
    timer_init();
 368:	a3 df       	rcall	.-186    	; 0x2b0 <timer_init>
 36a:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <shutdownState>

    // Grab the state of the shutdown circuity
    shutdownState = 0;
 36e:	78 94       	sei

    // Enable Interupts
    sei();					
 370:	ff cf       	rjmp	.-2      	; 0x370 <main+0xa>

00000372 <oneKHzTimer>:
 372:	0f 93       	push	r16

/**
 * @brief Core system's timer, 1ms, core of the pseudo RTOS system
 */
void oneKHzTimer(void)
{	
 374:	1f 93       	push	r17
 376:	cf 93       	push	r28
 378:	df 93       	push	r29
 37a:	cd b7       	in	r28, 0x3d	; 61
 37c:	de b7       	in	r29, 0x3e	; 62
 37e:	28 97       	sbiw	r28, 0x08	; 8
 380:	0f b6       	in	r0, 0x3f	; 63
 382:	f8 94       	cli
 384:	de bf       	out	0x3e, r29	; 62
 386:	0f be       	out	0x3f, r0	; 63
 388:	cd bf       	out	0x3d, r28	; 61
    // static uint8_t InputTempCount = 5;					// Number of iterations for the temp heartbeat trigger

    // static uint8_t CANInputSendTime = 0;					// Number of iterations for the input send trigger

	// flash the LED to show the system is running
	if(test_counter++ > 100)
 38a:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <test_counter.2480>
 38e:	90 91 09 02 	lds	r25, 0x0209	; 0x800209 <test_counter.2480+0x1>
 392:	9c 01       	movw	r18, r24
 394:	2f 5f       	subi	r18, 0xFF	; 255
 396:	3f 4f       	sbci	r19, 0xFF	; 255
 398:	30 93 09 02 	sts	0x0209, r19	; 0x800209 <test_counter.2480+0x1>
 39c:	20 93 08 02 	sts	0x0208, r18	; 0x800208 <test_counter.2480>
 3a0:	85 36       	cpi	r24, 0x65	; 101
 3a2:	91 05       	cpc	r25, r1
 3a4:	5c f0       	brlt	.+22     	; 0x3bc <oneKHzTimer+0x4a>
	{
		PORTK ^= 32;
 3a6:	e8 e0       	ldi	r30, 0x08	; 8
 3a8:	f1 e0       	ldi	r31, 0x01	; 1
 3aa:	90 81       	ld	r25, Z
 3ac:	80 e2       	ldi	r24, 0x20	; 32
 3ae:	89 27       	eor	r24, r25
 3b0:	80 83       	st	Z, r24
		test_counter = 0;
 3b2:	10 92 09 02 	sts	0x0209, r1	; 0x800209 <test_counter.2480+0x1>
 3b6:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <test_counter.2480>
		UART_formTestPacket();
 3ba:	af df       	rcall	.-162    	; 0x31a <UART_formTestPacket>
	
	
    // Check the ignition button state
    // 1s debounce, IE hold for 50ms and if held, change state
    // ------------------------------------------------------------------------
	if(!(PINJ & (1<<PJ6))) // Checking Pin J6 (69)
 3bc:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <__TEXT_REGION_LENGTH__+0x7e0103>
 3c0:	86 fd       	sbrc	r24, 6
 3c2:	1e c0       	rjmp	.+60     	; 0x400 <__LOCK_REGION_LENGTH__>
    {
        ignitionState = 1; // Tracks that the ignition button is on
 3c4:	81 e0       	ldi	r24, 0x01	; 1
 3c6:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <ignitionState>
        if(ignitionStateDebounceCount++ > 2000) // If 1s has been counted
 3ca:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <ignitionStateDebounceCount>
 3ce:	90 91 0f 02 	lds	r25, 0x020F	; 0x80020f <ignitionStateDebounceCount+0x1>
 3d2:	9c 01       	movw	r18, r24
 3d4:	2f 5f       	subi	r18, 0xFF	; 255
 3d6:	3f 4f       	sbci	r19, 0xFF	; 255
 3d8:	30 93 0f 02 	sts	0x020F, r19	; 0x80020f <ignitionStateDebounceCount+0x1>
 3dc:	20 93 0e 02 	sts	0x020E, r18	; 0x80020e <ignitionStateDebounceCount>
 3e0:	81 3d       	cpi	r24, 0xD1	; 209
 3e2:	97 40       	sbci	r25, 0x07	; 7
 3e4:	a8 f0       	brcs	.+42     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
		{
            //If this is the first time though from a previous press
            if(ignitionStateLock == 0) {
 3e6:	80 91 0d 02 	lds	r24, 0x020D	; 0x80020d <ignitionStateLock>
 3ea:	81 11       	cpse	r24, r1
 3ec:	11 c0       	rjmp	.+34     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
                ignitionStateLock = 1;		// Disabled first run though after press
 3ee:	81 e0       	ldi	r24, 0x01	; 1
 3f0:	80 93 0d 02 	sts	0x020D, r24	; 0x80020d <ignitionStateLock>
                armedState ^= 1;
 3f4:	90 91 0b 02 	lds	r25, 0x020B	; 0x80020b <armedState>
 3f8:	89 27       	eor	r24, r25
 3fa:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <armedState>
 3fe:	08 c0       	rjmp	.+16     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
            }
        }
    } 
    else
    {
        ignitionState = 0; // Tracks that the ignition button is off
 400:	10 92 0c 02 	sts	0x020C, r1	; 0x80020c <ignitionState>
        ignitionStateLock = 0; // Re-enables the first run though after the timer has been reached
 404:	10 92 0d 02 	sts	0x020D, r1	; 0x80020d <ignitionStateLock>
        ignitionStateDebounceCount = 0; // Resets the counter for time the button is pressed
 408:	10 92 0f 02 	sts	0x020F, r1	; 0x80020f <ignitionStateDebounceCount+0x1>
 40c:	10 92 0e 02 	sts	0x020E, r1	; 0x80020e <ignitionStateDebounceCount>
	
     //Send CAN heartbeats -> Inverters: 100Hz, Data: 100Hz, Power: 20Hz
     //100Hz = 1 / 100 = 0.01s = 10ms, 20Hz = 1 / 20 = 0.05s = 50ms
     //------------------------------------------------------------------------
    
	 uint8_t inverterArray[8] = {0,0,0,0,0,0,0,0};
 410:	fe 01       	movw	r30, r28
 412:	31 96       	adiw	r30, 0x01	; 1
 414:	88 e0       	ldi	r24, 0x08	; 8
 416:	df 01       	movw	r26, r30
 418:	1d 92       	st	X+, r1
 41a:	8a 95       	dec	r24
 41c:	e9 f7       	brne	.-6      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
	 if(CANheartbeatCountInverters > CAN_HEARTBEAT_TIME_INVERTERS)
 41e:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <CANheartbeatCountInverters.2481>
 422:	8b 30       	cpi	r24, 0x0B	; 11
 424:	50 f0       	brcs	.+20     	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
	 {
		 // Reset inverter heartbeat counter
		 CANheartbeatCountInverters = 0;
 426:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <CANheartbeatCountInverters.2481>
		 // Send inverter system heartbeat
		 CAN_send(MCP2515_CAN1, 8, inverterArray, 0b0100100000000000000000000011110);
 42a:	0e e1       	ldi	r16, 0x1E	; 30
 42c:	10 e0       	ldi	r17, 0x00	; 0
 42e:	20 e0       	ldi	r18, 0x00	; 0
 430:	34 e2       	ldi	r19, 0x24	; 36
 432:	af 01       	movw	r20, r30
 434:	68 e0       	ldi	r22, 0x08	; 8
 436:	81 e0       	ldi	r24, 0x01	; 1
 438:	9d de       	rcall	.-710    	; 0x174 <CAN_send>
		 CANheartbeatCountPower = 0;
		 // Send power system heartbeat
		 // CAN_send(MCP2515_CAN2, )
	 }
	 */
	 CANheartbeatCountInverters++;
 43a:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <CANheartbeatCountInverters.2481>
 43e:	8f 5f       	subi	r24, 0xFF	; 255
 440:	80 93 07 02 	sts	0x0207, r24	; 0x800207 <CANheartbeatCountInverters.2481>
	 CANheartbeatCountData++;
 444:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <CANheartbeatCountData.2482>
 448:	8f 5f       	subi	r24, 0xFF	; 255
 44a:	80 93 03 02 	sts	0x0203, r24	; 0x800203 <CANheartbeatCountData.2482>
	 CANheartbeatCountPower++;
 44e:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <CANheartbeatCountPower.2483>
 452:	8f 5f       	subi	r24, 0xFF	; 255
 454:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <CANheartbeatCountPower.2483>
    // CanHeartbeatErrorPower++;


    // Send CAN input
    // uint8_t tmpInputVal;
    if(InputPedalThrottleCount > INPUT_TIME_PEDAL_THROTTLE)
 458:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <InputPedalThrottleCount.2484>
 45c:	8b 30       	cpi	r24, 0x0B	; 11
    {
        INPUT_accelerationPedal = a2d_10bitCh(5);
 45e:	30 f0       	brcs	.+12     	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
 460:	85 e0       	ldi	r24, 0x05	; 5
 462:	5e de       	rcall	.-836    	; 0x120 <a2d_10bitCh>
 464:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <INPUT_accelerationPedal>
        // if(INPUT_get_accelPedal(&tmpInputVal) == 0) {
        //     // PORTK |= 0b00100000;
        //     INPUT_accelerationPedal = tmpInputVal;
        // }
        InputPedalThrottleCount = 0;
 468:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <InputPedalThrottleCount.2484>
    }

    if(InputPedalBrakeCount > INPUT_TIME_PEDAL_BRAKE)
 46c:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
 470:	8b 30       	cpi	r24, 0x0B	; 11
    {
        INPUT_brakePedal = a2d_10bitCh(10);
 472:	30 f0       	brcs	.+12     	; 0x480 <__LOCK_REGION_LENGTH__+0x80>
 474:	8a e0       	ldi	r24, 0x0A	; 10
 476:	54 de       	rcall	.-856    	; 0x120 <a2d_10bitCh>
 478:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <__data_end>
        // if(INPUT_get_brakePedal(&tmpInputVal) == 0) {
        //     INPUT_brakePedal = tmpInputVal;
        // }
        InputPedalBrakeCount = 0;
 47c:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <__data_start>
    }
    InputPedalThrottleCount++;
 480:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <InputPedalThrottleCount.2484>
 484:	8f 5f       	subi	r24, 0xFF	; 255
 486:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <InputPedalThrottleCount.2484>
    InputPedalBrakeCount++;
 48a:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
 48e:	8f 5f       	subi	r24, 0xFF	; 255
 490:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
    // }
    // if(INPUT_get_brakePressureFront(&tmpInputVal) == 0) {
    //     INPUT_brakePressureFront = tmpInputVal;
    // }
	
}
 494:	28 96       	adiw	r28, 0x08	; 8
 496:	0f b6       	in	r0, 0x3f	; 63
 498:	f8 94       	cli
 49a:	de bf       	out	0x3e, r29	; 62
 49c:	0f be       	out	0x3f, r0	; 63
 49e:	cd bf       	out	0x3d, r28	; 61
 4a0:	df 91       	pop	r29
 4a2:	cf 91       	pop	r28
 4a4:	1f 91       	pop	r17
 4a6:	0f 91       	pop	r16
 4a8:	08 95       	ret

000004aa <__vector_21>:

/**
 * @brief Called whenever the 1Khz timer triggers
 */
ISR(TIMER0_COMPA_vect)
{
 4aa:	1f 92       	push	r1
 4ac:	0f 92       	push	r0
 4ae:	0f b6       	in	r0, 0x3f	; 63
 4b0:	0f 92       	push	r0
 4b2:	11 24       	eor	r1, r1
 4b4:	0b b6       	in	r0, 0x3b	; 59
 4b6:	0f 92       	push	r0
 4b8:	2f 93       	push	r18
 4ba:	3f 93       	push	r19
 4bc:	4f 93       	push	r20
 4be:	5f 93       	push	r21
 4c0:	6f 93       	push	r22
 4c2:	7f 93       	push	r23
 4c4:	8f 93       	push	r24
 4c6:	9f 93       	push	r25
 4c8:	af 93       	push	r26
 4ca:	bf 93       	push	r27
 4cc:	ef 93       	push	r30
 4ce:	ff 93       	push	r31
    oneKHzTimer();
 4d0:	50 df       	rcall	.-352    	; 0x372 <oneKHzTimer>
    // led_toggle();
}
 4d2:	ff 91       	pop	r31
 4d4:	ef 91       	pop	r30
 4d6:	bf 91       	pop	r27
 4d8:	af 91       	pop	r26
 4da:	9f 91       	pop	r25
 4dc:	8f 91       	pop	r24
 4de:	7f 91       	pop	r23
 4e0:	6f 91       	pop	r22
 4e2:	5f 91       	pop	r21
 4e4:	4f 91       	pop	r20
 4e6:	3f 91       	pop	r19
 4e8:	2f 91       	pop	r18
 4ea:	0f 90       	pop	r0
 4ec:	0b be       	out	0x3b, r0	; 59
 4ee:	0f 90       	pop	r0
 4f0:	0f be       	out	0x3f, r0	; 63
 4f2:	0f 90       	pop	r0
 4f4:	1f 90       	pop	r1
 4f6:	18 95       	reti

000004f8 <__vector_17>:

ISR(TIMER1_COMPA_vect)
{
 4f8:	1f 92       	push	r1
 4fa:	0f 92       	push	r0
 4fc:	0f b6       	in	r0, 0x3f	; 63
 4fe:	0f 92       	push	r0
 500:	11 24       	eor	r1, r1

}
 502:	0f 90       	pop	r0
 504:	0f be       	out	0x3f, r0	; 63
 506:	0f 90       	pop	r0
 508:	1f 90       	pop	r1
 50a:	18 95       	reti

0000050c <__vector_2>:

/**
 * @brief Called whenever CANBUS 1 interupt is triggered
 *        * When ever there is data waiting in CAN 1
 */
ISR(INT1_vect) {
 50c:	1f 92       	push	r1
 50e:	0f 92       	push	r0
 510:	0f b6       	in	r0, 0x3f	; 63
 512:	0f 92       	push	r0
 514:	11 24       	eor	r1, r1
 516:	0b b6       	in	r0, 0x3b	; 59
 518:	0f 92       	push	r0
 51a:	2f 93       	push	r18
 51c:	3f 93       	push	r19
 51e:	4f 93       	push	r20
 520:	5f 93       	push	r21
 522:	6f 93       	push	r22
 524:	7f 93       	push	r23
 526:	8f 93       	push	r24
 528:	9f 93       	push	r25
 52a:	af 93       	push	r26
 52c:	bf 93       	push	r27
 52e:	ef 93       	push	r30
 530:	ff 93       	push	r31
 532:	cf 93       	push	r28
 534:	df 93       	push	r29
 536:	cd b7       	in	r28, 0x3d	; 61
 538:	de b7       	in	r29, 0x3e	; 62
 53a:	2d 97       	sbiw	r28, 0x0d	; 13
 53c:	de bf       	out	0x3e, r29	; 62
 53e:	cd bf       	out	0x3d, r28	; 61
	uint8_t data[8];
	uint32_t ID;
	uint8_t numBytes;

	// Get the data from the CAN bus and process it
	CAN_pull_packet(MCP2515_CAN1, &numBytes, data, &ID);
 540:	9e 01       	movw	r18, r28
 542:	27 5f       	subi	r18, 0xF7	; 247
 544:	3f 4f       	sbci	r19, 0xFF	; 255
 546:	ae 01       	movw	r20, r28
 548:	4f 5f       	subi	r20, 0xFF	; 255
 54a:	5f 4f       	sbci	r21, 0xFF	; 255
 54c:	be 01       	movw	r22, r28
 54e:	63 5f       	subi	r22, 0xF3	; 243
 550:	7f 4f       	sbci	r23, 0xFF	; 255
 552:	81 e0       	ldi	r24, 0x01	; 1
 554:	35 de       	rcall	.-918    	; 0x1c0 <CAN_pull_packet>

    // If the data packet is crap
    // throw_error_code(ERROR_LEVEL_WARN, ERROR_CANBUS_1_RESPONSE_MALFORMED);
}
 556:	2d 96       	adiw	r28, 0x0d	; 13
 558:	0f b6       	in	r0, 0x3f	; 63
 55a:	f8 94       	cli
 55c:	de bf       	out	0x3e, r29	; 62
 55e:	0f be       	out	0x3f, r0	; 63
 560:	cd bf       	out	0x3d, r28	; 61
 562:	df 91       	pop	r29
 564:	cf 91       	pop	r28
 566:	ff 91       	pop	r31
 568:	ef 91       	pop	r30
 56a:	bf 91       	pop	r27
 56c:	af 91       	pop	r26
 56e:	9f 91       	pop	r25
 570:	8f 91       	pop	r24
 572:	7f 91       	pop	r23
 574:	6f 91       	pop	r22
 576:	5f 91       	pop	r21
 578:	4f 91       	pop	r20
 57a:	3f 91       	pop	r19
 57c:	2f 91       	pop	r18
 57e:	0f 90       	pop	r0
 580:	0b be       	out	0x3b, r0	; 59
 582:	0f 90       	pop	r0
 584:	0f be       	out	0x3f, r0	; 63
 586:	0f 90       	pop	r0
 588:	1f 90       	pop	r1
 58a:	18 95       	reti

0000058c <__vector_1>:

/**
 * @brief Called whenever CANBUS 2 interupt is triggered
 *        * When ever there is data waiting in CAN 2
 */
ISR(INT0_vect)	{
 58c:	1f 92       	push	r1
 58e:	0f 92       	push	r0
 590:	0f b6       	in	r0, 0x3f	; 63
 592:	0f 92       	push	r0
 594:	11 24       	eor	r1, r1
 596:	0b b6       	in	r0, 0x3b	; 59
 598:	0f 92       	push	r0
 59a:	2f 93       	push	r18
 59c:	3f 93       	push	r19
 59e:	4f 93       	push	r20
 5a0:	5f 93       	push	r21
 5a2:	6f 93       	push	r22
 5a4:	7f 93       	push	r23
 5a6:	8f 93       	push	r24
 5a8:	9f 93       	push	r25
 5aa:	af 93       	push	r26
 5ac:	bf 93       	push	r27
 5ae:	ef 93       	push	r30
 5b0:	ff 93       	push	r31
 5b2:	cf 93       	push	r28
 5b4:	df 93       	push	r29
 5b6:	cd b7       	in	r28, 0x3d	; 61
 5b8:	de b7       	in	r29, 0x3e	; 62
 5ba:	2d 97       	sbiw	r28, 0x0d	; 13
 5bc:	de bf       	out	0x3e, r29	; 62
 5be:	cd bf       	out	0x3d, r28	; 61
	uint8_t data[8];
	uint32_t ID;
	uint8_t numBytes;

	// Get the data from the CAN bus and process it
	CAN_pull_packet(MCP2515_CAN2, &numBytes, data, &ID);
 5c0:	9e 01       	movw	r18, r28
 5c2:	27 5f       	subi	r18, 0xF7	; 247
 5c4:	3f 4f       	sbci	r19, 0xFF	; 255
 5c6:	ae 01       	movw	r20, r28
 5c8:	4f 5f       	subi	r20, 0xFF	; 255
 5ca:	5f 4f       	sbci	r21, 0xFF	; 255
 5cc:	be 01       	movw	r22, r28
 5ce:	63 5f       	subi	r22, 0xF3	; 243
 5d0:	7f 4f       	sbci	r23, 0xFF	; 255
 5d2:	82 e0       	ldi	r24, 0x02	; 2
 5d4:	f5 dd       	rcall	.-1046   	; 0x1c0 <CAN_pull_packet>

    // If the data packet is crap
    // throw_error_code(ERROR_LEVEL_WARN, ERROR_CANBUS_2_RESPONSE_MALFORMED);
}
 5d6:	2d 96       	adiw	r28, 0x0d	; 13
 5d8:	0f b6       	in	r0, 0x3f	; 63
 5da:	f8 94       	cli
 5dc:	de bf       	out	0x3e, r29	; 62
 5de:	0f be       	out	0x3f, r0	; 63
 5e0:	cd bf       	out	0x3d, r28	; 61
 5e2:	df 91       	pop	r29
 5e4:	cf 91       	pop	r28
 5e6:	ff 91       	pop	r31
 5e8:	ef 91       	pop	r30
 5ea:	bf 91       	pop	r27
 5ec:	af 91       	pop	r26
 5ee:	9f 91       	pop	r25
 5f0:	8f 91       	pop	r24
 5f2:	7f 91       	pop	r23
 5f4:	6f 91       	pop	r22
 5f6:	5f 91       	pop	r21
 5f8:	4f 91       	pop	r20
 5fa:	3f 91       	pop	r19
 5fc:	2f 91       	pop	r18
 5fe:	0f 90       	pop	r0
 600:	0b be       	out	0x3b, r0	; 59
 602:	0f 90       	pop	r0
 604:	0f be       	out	0x3f, r0	; 63
 606:	0f 90       	pop	r0
 608:	1f 90       	pop	r1
 60a:	18 95       	reti

0000060c <__vector_9>:

/**
 * @brief Called whenever CANBUS 3 interupt is triggered
 *        * When ever there is data waiting in CAN 3
 */
ISR(PCINT0_vect) {
 60c:	1f 92       	push	r1
 60e:	0f 92       	push	r0
 610:	0f b6       	in	r0, 0x3f	; 63
 612:	0f 92       	push	r0
 614:	11 24       	eor	r1, r1
 616:	0b b6       	in	r0, 0x3b	; 59
 618:	0f 92       	push	r0
 61a:	2f 93       	push	r18
 61c:	3f 93       	push	r19
 61e:	4f 93       	push	r20
 620:	5f 93       	push	r21
 622:	6f 93       	push	r22
 624:	7f 93       	push	r23
 626:	8f 93       	push	r24
 628:	9f 93       	push	r25
 62a:	af 93       	push	r26
 62c:	bf 93       	push	r27
 62e:	ef 93       	push	r30
 630:	ff 93       	push	r31
 632:	cf 93       	push	r28
 634:	df 93       	push	r29
 636:	cd b7       	in	r28, 0x3d	; 61
 638:	de b7       	in	r29, 0x3e	; 62
 63a:	2d 97       	sbiw	r28, 0x0d	; 13
 63c:	de bf       	out	0x3e, r29	; 62
 63e:	cd bf       	out	0x3d, r28	; 61
	uint8_t data[8];
	uint32_t ID;
	uint8_t numBytes;

	// Get the data from the CAN bus and process it
	CAN_pull_packet(MCP2515_CAN3, &numBytes, data, &ID);
 640:	9e 01       	movw	r18, r28
 642:	27 5f       	subi	r18, 0xF7	; 247
 644:	3f 4f       	sbci	r19, 0xFF	; 255
 646:	ae 01       	movw	r20, r28
 648:	4f 5f       	subi	r20, 0xFF	; 255
 64a:	5f 4f       	sbci	r21, 0xFF	; 255
 64c:	be 01       	movw	r22, r28
 64e:	63 5f       	subi	r22, 0xF3	; 243
 650:	7f 4f       	sbci	r23, 0xFF	; 255
 652:	84 e0       	ldi	r24, 0x04	; 4
 654:	b5 dd       	rcall	.-1174   	; 0x1c0 <CAN_pull_packet>

    // If the data packet is crap
    // throw_error_code(ERROR_LEVEL_WARN, ERROR_CANBUS_3_RESPONSE_MALFORMED);
 656:	2d 96       	adiw	r28, 0x0d	; 13
 658:	0f b6       	in	r0, 0x3f	; 63
 65a:	f8 94       	cli
 65c:	de bf       	out	0x3e, r29	; 62
 65e:	0f be       	out	0x3f, r0	; 63
 660:	cd bf       	out	0x3d, r28	; 61
 662:	df 91       	pop	r29
 664:	cf 91       	pop	r28
 666:	ff 91       	pop	r31
 668:	ef 91       	pop	r30
 66a:	bf 91       	pop	r27
 66c:	af 91       	pop	r26
 66e:	9f 91       	pop	r25
 670:	8f 91       	pop	r24
 672:	7f 91       	pop	r23
 674:	6f 91       	pop	r22
 676:	5f 91       	pop	r21
 678:	4f 91       	pop	r20
 67a:	3f 91       	pop	r19
 67c:	2f 91       	pop	r18
 67e:	0f 90       	pop	r0
 680:	0b be       	out	0x3b, r0	; 59
 682:	0f 90       	pop	r0
 684:	0f be       	out	0x3f, r0	; 63
 686:	0f 90       	pop	r0
 688:	1f 90       	pop	r1
 68a:	18 95       	reti

0000068c <MCP2515_CS_low>:
			MCP2515_reg_write(CANbus, MCP2515_RXM1EID0, IDmsk & 0xFF );
			if(IDmsk) MCP2515_reg_write(CANbus, MCP2515_RXB1CTRL, 0b00000000);	//Enable reception using masks and filters. 
			else MCP2515_reg_write(CANbus, MCP2515_RXB1CTRL, 0b01100000);		//Enable reception without masks and filters.
	}	
	return 1;
}
 68c:	82 30       	cpi	r24, 0x02	; 2
 68e:	51 f0       	breq	.+20     	; 0x6a4 <MCP2515_CS_low+0x18>
 690:	84 30       	cpi	r24, 0x04	; 4
 692:	71 f0       	breq	.+28     	; 0x6b0 <MCP2515_CS_low+0x24>
 694:	81 30       	cpi	r24, 0x01	; 1
 696:	69 f4       	brne	.+26     	; 0x6b2 <MCP2515_CS_low+0x26>
 698:	e2 e0       	ldi	r30, 0x02	; 2
 69a:	f1 e0       	ldi	r31, 0x01	; 1
 69c:	80 81       	ld	r24, Z
 69e:	8e 7f       	andi	r24, 0xFE	; 254
 6a0:	80 83       	st	Z, r24
 6a2:	08 95       	ret
 6a4:	e2 e0       	ldi	r30, 0x02	; 2
 6a6:	f1 e0       	ldi	r31, 0x01	; 1
 6a8:	80 81       	ld	r24, Z
 6aa:	8d 7f       	andi	r24, 0xFD	; 253
 6ac:	80 83       	st	Z, r24
 6ae:	08 95       	ret
 6b0:	28 98       	cbi	0x05, 0	; 5
 6b2:	08 95       	ret

000006b4 <MCP2515_CS_high>:
 6b4:	82 30       	cpi	r24, 0x02	; 2
 6b6:	51 f0       	breq	.+20     	; 0x6cc <MCP2515_CS_high+0x18>
 6b8:	84 30       	cpi	r24, 0x04	; 4
 6ba:	71 f0       	breq	.+28     	; 0x6d8 <MCP2515_CS_high+0x24>
 6bc:	81 30       	cpi	r24, 0x01	; 1
 6be:	69 f4       	brne	.+26     	; 0x6da <MCP2515_CS_high+0x26>
 6c0:	e2 e0       	ldi	r30, 0x02	; 2
 6c2:	f1 e0       	ldi	r31, 0x01	; 1
 6c4:	80 81       	ld	r24, Z
 6c6:	81 60       	ori	r24, 0x01	; 1
 6c8:	80 83       	st	Z, r24
 6ca:	08 95       	ret
 6cc:	e2 e0       	ldi	r30, 0x02	; 2
 6ce:	f1 e0       	ldi	r31, 0x01	; 1
 6d0:	80 81       	ld	r24, Z
 6d2:	82 60       	ori	r24, 0x02	; 2
 6d4:	80 83       	st	Z, r24
 6d6:	08 95       	ret
 6d8:	28 9a       	sbi	0x05, 0	; 5
 6da:	08 95       	ret

000006dc <MCP2515_reg_write>:
 6dc:	1f 93       	push	r17
 6de:	cf 93       	push	r28
 6e0:	df 93       	push	r29
 6e2:	c8 2f       	mov	r28, r24
 6e4:	16 2f       	mov	r17, r22
 6e6:	d4 2f       	mov	r29, r20
 6e8:	d1 df       	rcall	.-94     	; 0x68c <MCP2515_CS_low>
 6ea:	82 e0       	ldi	r24, 0x02	; 2
 6ec:	8c d1       	rcall	.+792    	; 0xa06 <SPI_send_byte>
 6ee:	81 2f       	mov	r24, r17
 6f0:	8a d1       	rcall	.+788    	; 0xa06 <SPI_send_byte>
 6f2:	8d 2f       	mov	r24, r29
 6f4:	88 d1       	rcall	.+784    	; 0xa06 <SPI_send_byte>
 6f6:	8c 2f       	mov	r24, r28
 6f8:	dd df       	rcall	.-70     	; 0x6b4 <MCP2515_CS_high>
 6fa:	df 91       	pop	r29
 6fc:	cf 91       	pop	r28
 6fe:	1f 91       	pop	r17
 700:	08 95       	ret

00000702 <MCP2515_instruction>:
 702:	cf 93       	push	r28
 704:	df 93       	push	r29
 706:	c8 2f       	mov	r28, r24
 708:	d6 2f       	mov	r29, r22
 70a:	c0 df       	rcall	.-128    	; 0x68c <MCP2515_CS_low>
 70c:	8d 2f       	mov	r24, r29
 70e:	7b d1       	rcall	.+758    	; 0xa06 <SPI_send_byte>
 710:	8c 2f       	mov	r24, r28
 712:	d0 df       	rcall	.-96     	; 0x6b4 <MCP2515_CS_high>
 714:	df 91       	pop	r29
 716:	cf 91       	pop	r28
 718:	08 95       	ret

0000071a <MCP2515_bit_modify>:
 71a:	0f 93       	push	r16
 71c:	1f 93       	push	r17
 71e:	cf 93       	push	r28
 720:	df 93       	push	r29
 722:	c8 2f       	mov	r28, r24
 724:	06 2f       	mov	r16, r22
 726:	d4 2f       	mov	r29, r20
 728:	12 2f       	mov	r17, r18
 72a:	b0 df       	rcall	.-160    	; 0x68c <MCP2515_CS_low>
 72c:	85 e0       	ldi	r24, 0x05	; 5
 72e:	6b d1       	rcall	.+726    	; 0xa06 <SPI_send_byte>
 730:	80 2f       	mov	r24, r16
 732:	69 d1       	rcall	.+722    	; 0xa06 <SPI_send_byte>
 734:	81 2f       	mov	r24, r17
 736:	67 d1       	rcall	.+718    	; 0xa06 <SPI_send_byte>
 738:	8d 2f       	mov	r24, r29
 73a:	65 d1       	rcall	.+714    	; 0xa06 <SPI_send_byte>
 73c:	8c 2f       	mov	r24, r28
 73e:	ba df       	rcall	.-140    	; 0x6b4 <MCP2515_CS_high>
 740:	df 91       	pop	r29
 742:	cf 91       	pop	r28
 744:	1f 91       	pop	r17
 746:	0f 91       	pop	r16
 748:	08 95       	ret

0000074a <MCP2515_init>:
 74a:	cf 93       	push	r28
 74c:	c8 2f       	mov	r28, r24
 74e:	60 ec       	ldi	r22, 0xC0	; 192
 750:	d8 df       	rcall	.-80     	; 0x702 <MCP2515_instruction>
 752:	20 ee       	ldi	r18, 0xE0	; 224
 754:	40 e8       	ldi	r20, 0x80	; 128
 756:	6f e0       	ldi	r22, 0x0F	; 15
 758:	8c 2f       	mov	r24, r28
 75a:	df df       	rcall	.-66     	; 0x71a <MCP2515_bit_modify>
 75c:	44 e0       	ldi	r20, 0x04	; 4
 75e:	6a e2       	ldi	r22, 0x2A	; 42
 760:	8c 2f       	mov	r24, r28
 762:	bc df       	rcall	.-136    	; 0x6dc <MCP2515_reg_write>
 764:	4a ec       	ldi	r20, 0xCA	; 202
 766:	69 e2       	ldi	r22, 0x29	; 41
 768:	8c 2f       	mov	r24, r28
 76a:	b8 df       	rcall	.-144    	; 0x6dc <MCP2515_reg_write>
 76c:	41 e0       	ldi	r20, 0x01	; 1
 76e:	68 e2       	ldi	r22, 0x28	; 40
 770:	8c 2f       	mov	r24, r28
 772:	b4 df       	rcall	.-152    	; 0x6dc <MCP2515_reg_write>
 774:	43 e0       	ldi	r20, 0x03	; 3
 776:	6b e2       	ldi	r22, 0x2B	; 43
 778:	8c 2f       	mov	r24, r28
 77a:	b0 df       	rcall	.-160    	; 0x6dc <MCP2515_reg_write>
 77c:	41 e0       	ldi	r20, 0x01	; 1
 77e:	6d e0       	ldi	r22, 0x0D	; 13
 780:	8c 2f       	mov	r24, r28
 782:	ac df       	rcall	.-168    	; 0x6dc <MCP2515_reg_write>
 784:	20 ee       	ldi	r18, 0xE0	; 224
 786:	40 e0       	ldi	r20, 0x00	; 0
 788:	6f e0       	ldi	r22, 0x0F	; 15
 78a:	8c 2f       	mov	r24, r28
 78c:	c6 df       	rcall	.-116    	; 0x71a <MCP2515_bit_modify>
 78e:	cf 91       	pop	r28
 790:	08 95       	ret

00000792 <MCP2515_PullCanPacket>:
 792:	7f 92       	push	r7
 794:	8f 92       	push	r8
 796:	9f 92       	push	r9
 798:	af 92       	push	r10
 79a:	bf 92       	push	r11
 79c:	cf 92       	push	r12
 79e:	df 92       	push	r13
 7a0:	ef 92       	push	r14
 7a2:	ff 92       	push	r15
 7a4:	0f 93       	push	r16
 7a6:	1f 93       	push	r17
 7a8:	cf 93       	push	r28
 7aa:	df 93       	push	r29
 7ac:	cd b7       	in	r28, 0x3d	; 61
 7ae:	de b7       	in	r29, 0x3e	; 62
 7b0:	2d 97       	sbiw	r28, 0x0d	; 13
 7b2:	0f b6       	in	r0, 0x3f	; 63
 7b4:	f8 94       	cli
 7b6:	de bf       	out	0x3e, r29	; 62
 7b8:	0f be       	out	0x3f, r0	; 63
 7ba:	cd bf       	out	0x3d, r28	; 61
 7bc:	78 2e       	mov	r7, r24
 7be:	4a 01       	movw	r8, r20
 7c0:	59 01       	movw	r10, r18
 7c2:	61 37       	cpi	r22, 0x71	; 113
 7c4:	28 f4       	brcc	.+10     	; 0x7d0 <MCP2515_PullCanPacket+0x3e>
 7c6:	0f 2e       	mov	r0, r31
 7c8:	f0 e9       	ldi	r31, 0x90	; 144
 7ca:	ff 2e       	mov	r15, r31
 7cc:	f0 2d       	mov	r31, r0
 7ce:	04 c0       	rjmp	.+8      	; 0x7d8 <MCP2515_PullCanPacket+0x46>
 7d0:	0f 2e       	mov	r0, r31
 7d2:	f4 e9       	ldi	r31, 0x94	; 148
 7d4:	ff 2e       	mov	r15, r31
 7d6:	f0 2d       	mov	r31, r0
 7d8:	87 2d       	mov	r24, r7
 7da:	58 df       	rcall	.-336    	; 0x68c <MCP2515_CS_low>
 7dc:	8f 2d       	mov	r24, r15
 7de:	13 d1       	rcall	.+550    	; 0xa06 <SPI_send_byte>
 7e0:	ce 01       	movw	r24, r28
 7e2:	01 96       	adiw	r24, 0x01	; 1
 7e4:	7c 01       	movw	r14, r24
 7e6:	6e 01       	movw	r12, r28
 7e8:	9e e0       	ldi	r25, 0x0E	; 14
 7ea:	c9 0e       	add	r12, r25
 7ec:	d1 1c       	adc	r13, r1
 7ee:	80 e0       	ldi	r24, 0x00	; 0
 7f0:	0a d1       	rcall	.+532    	; 0xa06 <SPI_send_byte>
 7f2:	f7 01       	movw	r30, r14
 7f4:	81 93       	st	Z+, r24
 7f6:	7f 01       	movw	r14, r30
 7f8:	ec 15       	cp	r30, r12
 7fa:	fd 05       	cpc	r31, r13
 7fc:	c1 f7       	brne	.-16     	; 0x7ee <MCP2515_PullCanPacket+0x5c>
 7fe:	2a 81       	ldd	r18, Y+2	; 0x02
 800:	89 81       	ldd	r24, Y+1	; 0x01
 802:	90 e0       	ldi	r25, 0x00	; 0
 804:	a0 e0       	ldi	r26, 0x00	; 0
 806:	b0 e0       	ldi	r27, 0x00	; 0
 808:	07 2e       	mov	r0, r23
 80a:	75 e1       	ldi	r23, 0x15	; 21
 80c:	88 0f       	add	r24, r24
 80e:	99 1f       	adc	r25, r25
 810:	aa 1f       	adc	r26, r26
 812:	bb 1f       	adc	r27, r27
 814:	7a 95       	dec	r23
 816:	d1 f7       	brne	.-12     	; 0x80c <MCP2515_PullCanPacket+0x7a>
 818:	70 2d       	mov	r23, r0
 81a:	3b 81       	ldd	r19, Y+3	; 0x03
 81c:	93 2b       	or	r25, r19
 81e:	3c 81       	ldd	r19, Y+4	; 0x04
 820:	83 2b       	or	r24, r19
 822:	42 2f       	mov	r20, r18
 824:	40 7e       	andi	r20, 0xE0	; 224
 826:	50 e0       	ldi	r21, 0x00	; 0
 828:	60 e0       	ldi	r22, 0x00	; 0
 82a:	70 e0       	ldi	r23, 0x00	; 0
 82c:	03 2e       	mov	r0, r19
 82e:	3d e0       	ldi	r19, 0x0D	; 13
 830:	44 0f       	add	r20, r20
 832:	55 1f       	adc	r21, r21
 834:	66 1f       	adc	r22, r22
 836:	77 1f       	adc	r23, r23
 838:	3a 95       	dec	r19
 83a:	d1 f7       	brne	.-12     	; 0x830 <MCP2515_PullCanPacket+0x9e>
 83c:	30 2d       	mov	r19, r0
 83e:	84 2b       	or	r24, r20
 840:	95 2b       	or	r25, r21
 842:	a6 2b       	or	r26, r22
 844:	b7 2b       	or	r27, r23
 846:	23 70       	andi	r18, 0x03	; 3
 848:	a2 2b       	or	r26, r18
 84a:	f8 01       	movw	r30, r16
 84c:	80 83       	st	Z, r24
 84e:	91 83       	std	Z+1, r25	; 0x01
 850:	a2 83       	std	Z+2, r26	; 0x02
 852:	b3 83       	std	Z+3, r27	; 0x03
 854:	4d 85       	ldd	r20, Y+13	; 0x0d
 856:	4f 70       	andi	r20, 0x0F	; 15
 858:	f4 01       	movw	r30, r8
 85a:	40 83       	st	Z, r20
 85c:	50 e0       	ldi	r21, 0x00	; 0
 85e:	be 01       	movw	r22, r28
 860:	6b 5f       	subi	r22, 0xFB	; 251
 862:	7f 4f       	sbci	r23, 0xFF	; 255
 864:	c5 01       	movw	r24, r10
 866:	e1 d1       	rcall	.+962    	; 0xc2a <memcpy>
 868:	87 2d       	mov	r24, r7
 86a:	24 df       	rcall	.-440    	; 0x6b4 <MCP2515_CS_high>
 86c:	2d 96       	adiw	r28, 0x0d	; 13
 86e:	0f b6       	in	r0, 0x3f	; 63
 870:	f8 94       	cli
 872:	de bf       	out	0x3e, r29	; 62
 874:	0f be       	out	0x3f, r0	; 63
 876:	cd bf       	out	0x3d, r28	; 61
 878:	df 91       	pop	r29
 87a:	cf 91       	pop	r28
 87c:	1f 91       	pop	r17
 87e:	0f 91       	pop	r16
 880:	ff 90       	pop	r15
 882:	ef 90       	pop	r14
 884:	df 90       	pop	r13
 886:	cf 90       	pop	r12
 888:	bf 90       	pop	r11
 88a:	af 90       	pop	r10
 88c:	9f 90       	pop	r9
 88e:	8f 90       	pop	r8
 890:	7f 90       	pop	r7
 892:	08 95       	ret

00000894 <MCP2515_reg_read>:
 894:	cf 93       	push	r28
 896:	df 93       	push	r29
 898:	c8 2f       	mov	r28, r24
 89a:	d6 2f       	mov	r29, r22
 89c:	f7 de       	rcall	.-530    	; 0x68c <MCP2515_CS_low>
 89e:	83 e0       	ldi	r24, 0x03	; 3
 8a0:	b2 d0       	rcall	.+356    	; 0xa06 <SPI_send_byte>
 8a2:	8d 2f       	mov	r24, r29
 8a4:	b0 d0       	rcall	.+352    	; 0xa06 <SPI_send_byte>
 8a6:	80 e0       	ldi	r24, 0x00	; 0
 8a8:	ae d0       	rcall	.+348    	; 0xa06 <SPI_send_byte>
 8aa:	d8 2f       	mov	r29, r24
 8ac:	8c 2f       	mov	r24, r28
 8ae:	02 df       	rcall	.-508    	; 0x6b4 <MCP2515_CS_high>
 8b0:	8d 2f       	mov	r24, r29
 8b2:	df 91       	pop	r29
 8b4:	cf 91       	pop	r28
 8b6:	08 95       	ret

000008b8 <MCP2515_findFreeTxBuffer>:
 8b8:	cf 93       	push	r28
 8ba:	c8 2f       	mov	r28, r24
 8bc:	60 e3       	ldi	r22, 0x30	; 48
 8be:	ea df       	rcall	.-44     	; 0x894 <MCP2515_reg_read>
 8c0:	83 ff       	sbrs	r24, 3
 8c2:	0c c0       	rjmp	.+24     	; 0x8dc <MCP2515_findFreeTxBuffer+0x24>
 8c4:	60 e4       	ldi	r22, 0x40	; 64
 8c6:	8c 2f       	mov	r24, r28
 8c8:	e5 df       	rcall	.-54     	; 0x894 <MCP2515_reg_read>
 8ca:	83 ff       	sbrs	r24, 3
 8cc:	09 c0       	rjmp	.+18     	; 0x8e0 <MCP2515_findFreeTxBuffer+0x28>
 8ce:	60 e5       	ldi	r22, 0x50	; 80
 8d0:	8c 2f       	mov	r24, r28
 8d2:	e0 df       	rcall	.-64     	; 0x894 <MCP2515_reg_read>
 8d4:	83 ff       	sbrs	r24, 3
 8d6:	06 c0       	rjmp	.+12     	; 0x8e4 <MCP2515_findFreeTxBuffer+0x2c>
 8d8:	80 e0       	ldi	r24, 0x00	; 0
 8da:	05 c0       	rjmp	.+10     	; 0x8e6 <MCP2515_findFreeTxBuffer+0x2e>
 8dc:	80 e3       	ldi	r24, 0x30	; 48
 8de:	03 c0       	rjmp	.+6      	; 0x8e6 <MCP2515_findFreeTxBuffer+0x2e>
 8e0:	80 e4       	ldi	r24, 0x40	; 64
 8e2:	01 c0       	rjmp	.+2      	; 0x8e6 <MCP2515_findFreeTxBuffer+0x2e>
 8e4:	80 e5       	ldi	r24, 0x50	; 80
 8e6:	cf 91       	pop	r28
 8e8:	08 95       	ret

000008ea <MCP2515_TX>:

void MCP2515_TX(uint8_t CANbus, int8_t mob, uint8_t numBytes, uint8_t * data, uint32_t ID)
{
 8ea:	8f 92       	push	r8
 8ec:	9f 92       	push	r9
 8ee:	af 92       	push	r10
 8f0:	bf 92       	push	r11
 8f2:	df 92       	push	r13
 8f4:	ef 92       	push	r14
 8f6:	ff 92       	push	r15
 8f8:	0f 93       	push	r16
 8fa:	1f 93       	push	r17
 8fc:	cf 93       	push	r28
 8fe:	df 93       	push	r29
	if(mob == 0)return;						//no free mob or invalid mob
 900:	66 23       	and	r22, r22
 902:	09 f4       	brne	.+2      	; 0x906 <MCP2515_TX+0x1c>
 904:	63 c0       	rjmp	.+198    	; 0x9cc <MCP2515_TX+0xe2>
 906:	47 01       	movw	r8, r14
 908:	58 01       	movw	r10, r16
 90a:	c3 2f       	mov	r28, r19
 90c:	e2 2e       	mov	r14, r18
 90e:	d4 2e       	mov	r13, r20
 910:	f6 2e       	mov	r15, r22
 912:	d8 2f       	mov	r29, r24
	MCP2515_reg_write(CANbus, mob, 0x03);			//we shall set this to the highest priority so that it sends it immediately.
 914:	43 e0       	ldi	r20, 0x03	; 3
 916:	e2 de       	rcall	.-572    	; 0x6dc <MCP2515_reg_write>
	MCP2515_reg_write(CANbus, mob+1, (ID>>21) & 0xFF);	//shift the ID data to fill the respective MCP registers
 918:	b5 01       	movw	r22, r10
 91a:	a4 01       	movw	r20, r8
 91c:	03 2e       	mov	r0, r19
 91e:	35 e1       	ldi	r19, 0x15	; 21
 920:	76 95       	lsr	r23
 922:	67 95       	ror	r22
 924:	57 95       	ror	r21
 926:	47 95       	ror	r20
 928:	3a 95       	dec	r19
 92a:	d1 f7       	brne	.-12     	; 0x920 <MCP2515_TX+0x36>
 92c:	30 2d       	mov	r19, r0
 92e:	81 e0       	ldi	r24, 0x01	; 1
 930:	8f 0d       	add	r24, r15
 932:	68 2f       	mov	r22, r24
 934:	8d 2f       	mov	r24, r29
 936:	d2 de       	rcall	.-604    	; 0x6dc <MCP2515_reg_write>
	MCP2515_reg_write(CANbus, mob+2, (((ID>>13) & 224)| ((ID>>16) & 3) | ((1<<3) & 0xFF)));	//set the EXIDE bit, which makes it extended (CAN 2.0B)
 938:	b5 01       	movw	r22, r10
 93a:	a4 01       	movw	r20, r8
 93c:	03 2e       	mov	r0, r19
 93e:	3d e0       	ldi	r19, 0x0D	; 13
 940:	76 95       	lsr	r23
 942:	67 95       	ror	r22
 944:	57 95       	ror	r21
 946:	47 95       	ror	r20
 948:	3a 95       	dec	r19
 94a:	d1 f7       	brne	.-12     	; 0x940 <MCP2515_TX+0x56>
 94c:	30 2d       	mov	r19, r0
 94e:	40 7e       	andi	r20, 0xE0	; 224
 950:	8a 2d       	mov	r24, r10
 952:	83 70       	andi	r24, 0x03	; 3
 954:	48 2b       	or	r20, r24
 956:	48 60       	ori	r20, 0x08	; 8
 958:	62 e0       	ldi	r22, 0x02	; 2
 95a:	6f 0d       	add	r22, r15
 95c:	8d 2f       	mov	r24, r29
 95e:	be de       	rcall	.-644    	; 0x6dc <MCP2515_reg_write>
	MCP2515_reg_write(CANbus, mob+3, (ID>>8) & 0xFF );
 960:	77 27       	eor	r23, r23
 962:	6b 2d       	mov	r22, r11
 964:	5a 2d       	mov	r21, r10
 966:	49 2d       	mov	r20, r9
 968:	83 e0       	ldi	r24, 0x03	; 3
 96a:	8f 0d       	add	r24, r15
 96c:	68 2f       	mov	r22, r24
 96e:	8d 2f       	mov	r24, r29
 970:	b5 de       	rcall	.-662    	; 0x6dc <MCP2515_reg_write>
	MCP2515_reg_write(CANbus, mob+4, ID & 0xFF );
 972:	64 e0       	ldi	r22, 0x04	; 4
 974:	6f 0d       	add	r22, r15
 976:	48 2d       	mov	r20, r8
 978:	8d 2f       	mov	r24, r29
 97a:	b0 de       	rcall	.-672    	; 0x6dc <MCP2515_reg_write>
	MCP2515_reg_write(CANbus, mob+5, numBytes);		//set how many bytes we wish to send
 97c:	65 e0       	ldi	r22, 0x05	; 5
 97e:	6f 0d       	add	r22, r15
 980:	4d 2d       	mov	r20, r13
 982:	8d 2f       	mov	r24, r29
 984:	ab de       	rcall	.-682    	; 0x6dc <MCP2515_reg_write>
 986:	dd 20       	and	r13, r13
	//MCP2515_reg_write(CANbus, mob+2, (1<<3));
	//MCP2515_reg_write(CANbus, mob+3, 0);
	//MCP2515_reg_write(CANbus, mob+4, 0);
	//MCP2515_reg_write(CANbus, mob+5, 0);
	
	for (uint8_t byteCount = 0; byteCount < numBytes; byteCount++)
 988:	89 f0       	breq	.+34     	; 0x9ac <MCP2515_TX+0xc2>
 98a:	0e 2d       	mov	r16, r14
 98c:	1c 2f       	mov	r17, r28
 98e:	c6 e0       	ldi	r28, 0x06	; 6
 990:	cf 0d       	add	r28, r15
 992:	46 e0       	ldi	r20, 0x06	; 6
 994:	4d 0d       	add	r20, r13
 996:	e4 2e       	mov	r14, r20
 998:	ef 0c       	add	r14, r15
	{
		MCP2515_reg_write(CANbus, mob+6+byteCount, *(data+byteCount));	//fill the data bytes register.
 99a:	f8 01       	movw	r30, r16
 99c:	41 91       	ld	r20, Z+
 99e:	8f 01       	movw	r16, r30
 9a0:	6c 2f       	mov	r22, r28
 9a2:	8d 2f       	mov	r24, r29
 9a4:	9b de       	rcall	.-714    	; 0x6dc <MCP2515_reg_write>
 9a6:	cf 5f       	subi	r28, 0xFF	; 255
 9a8:	ce 11       	cpse	r28, r14
	//MCP2515_reg_write(CANbus, mob+2, (1<<3));
	//MCP2515_reg_write(CANbus, mob+3, 0);
	//MCP2515_reg_write(CANbus, mob+4, 0);
	//MCP2515_reg_write(CANbus, mob+5, 0);
	
	for (uint8_t byteCount = 0; byteCount < numBytes; byteCount++)
 9aa:	f7 cf       	rjmp	.-18     	; 0x99a <MCP2515_TX+0xb0>
 9ac:	8f 2d       	mov	r24, r15
	{
		MCP2515_reg_write(CANbus, mob+6+byteCount, *(data+byteCount));	//fill the data bytes register.
	}
	MCP2515_instruction(CANbus, 128|(1<<((mob>>4) - 3)));		//creates an instruction that matches the mob that is chosen.
 9ae:	85 95       	asr	r24
 9b0:	85 95       	asr	r24
 9b2:	85 95       	asr	r24
 9b4:	85 95       	asr	r24
 9b6:	83 50       	subi	r24, 0x03	; 3
 9b8:	61 e0       	ldi	r22, 0x01	; 1
 9ba:	70 e0       	ldi	r23, 0x00	; 0
 9bc:	02 c0       	rjmp	.+4      	; 0x9c2 <MCP2515_TX+0xd8>
 9be:	66 0f       	add	r22, r22
 9c0:	77 1f       	adc	r23, r23
 9c2:	8a 95       	dec	r24
 9c4:	e2 f7       	brpl	.-8      	; 0x9be <MCP2515_TX+0xd4>
 9c6:	60 68       	ori	r22, 0x80	; 128
 9c8:	8d 2f       	mov	r24, r29
 9ca:	9b de       	rcall	.-714    	; 0x702 <MCP2515_instruction>
 9cc:	df 91       	pop	r29
	//PORTC &= ~(1<<PINC7);		//Drop the TX
	//_delay_us(50);
	//PORTC |= (1<<PINC7);		
}
 9ce:	cf 91       	pop	r28
 9d0:	1f 91       	pop	r17
 9d2:	0f 91       	pop	r16
 9d4:	ff 90       	pop	r15
 9d6:	ef 90       	pop	r14
 9d8:	df 90       	pop	r13
 9da:	bf 90       	pop	r11
 9dc:	af 90       	pop	r10
 9de:	9f 90       	pop	r9
 9e0:	8f 90       	pop	r8
 9e2:	08 95       	ret

000009e4 <MCP2515_check_receive_status>:
 9e4:	cf 93       	push	r28


uint8_t MCP2515_check_receive_status(uint8_t CANbus)
{
 9e6:	df 93       	push	r29
 9e8:	c8 2f       	mov	r28, r24
	uint8_t status;
	MCP2515_CS_low(CANbus);			//unset CS so MCP2515 knows we are talking
 9ea:	50 de       	rcall	.-864    	; 0x68c <MCP2515_CS_low>
	SPI_send_byte(MCP2515_RXSTATUS);
 9ec:	80 eb       	ldi	r24, 0xB0	; 176
 9ee:	0b d0       	rcall	.+22     	; 0xa06 <SPI_send_byte>
	status = SPI_send_byte(0x00);						//send zeros to get data
 9f0:	80 e0       	ldi	r24, 0x00	; 0
 9f2:	09 d0       	rcall	.+18     	; 0xa06 <SPI_send_byte>
 9f4:	d8 2f       	mov	r29, r24
	SPI_send_byte(0x00);							//MCP2515 will repeat the data output, so send another batch of zeros
 9f6:	80 e0       	ldi	r24, 0x00	; 0
 9f8:	06 d0       	rcall	.+12     	; 0xa06 <SPI_send_byte>
	MCP2515_CS_high(CANbus);			//set the CS
 9fa:	8c 2f       	mov	r24, r28
 9fc:	5b de       	rcall	.-842    	; 0x6b4 <MCP2515_CS_high>
 9fe:	8d 2f       	mov	r24, r29
	return status;
}
 a00:	df 91       	pop	r29
 a02:	cf 91       	pop	r28
 a04:	08 95       	ret

00000a06 <SPI_send_byte>:
#include "SPI.h"

uint8_t SPI_send_byte(uint8_t c)
{
	SPDR = c;					//write data to the transmission register. Writing to this initiates transmission.
 a06:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
 a08:	0d b4       	in	r0, 0x2d	; 45
 a0a:	07 fe       	sbrs	r0, 7
 a0c:	fd cf       	rjmp	.-6      	; 0xa08 <SPI_send_byte+0x2>
	return SPDR;				//return any data that was shifted into this register upon transmission.
 a0e:	8e b5       	in	r24, 0x2e	; 46
}
 a10:	08 95       	ret

00000a12 <SPI_init>:

void SPI_init()
{
	//MCUCR &= ~(1<<SPIPS);		//make sure we are getting spi not on the _A spi pins.
	SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(1<<SPR0)|(0<<SPR1);  //set interrupt, enable SPI, MSB mode, set as master, low is idle, read on leading edge, Set to speed(fosc/64) SPR0=1, SPR1=0
 a12:	81 e5       	ldi	r24, 0x51	; 81
 a14:	8c bd       	out	0x2c, r24	; 44
	SPSR = (1<<SPI2X);	//set whether we want 2x speed or not (1=2x speed).
 a16:	81 e0       	ldi	r24, 0x01	; 1
 a18:	8d bd       	out	0x2d, r24	; 45
	SPDR = 0x00;		//ensure data register has nothing in it
 a1a:	1e bc       	out	0x2e, r1	; 46
 a1c:	08 95       	ret

00000a1e <__vector_25>:
    /* get data from receive buffer */
    data1 = UART1_RxBuf[tmptail1];
    
    return (UART1_LastRxError << 8) + data1;

}/* uart1_getc */
 a1e:	1f 92       	push	r1
 a20:	0f 92       	push	r0
 a22:	0f b6       	in	r0, 0x3f	; 63
 a24:	0f 92       	push	r0
 a26:	11 24       	eor	r1, r1
 a28:	0b b6       	in	r0, 0x3b	; 59
 a2a:	0f 92       	push	r0
 a2c:	2f 93       	push	r18
 a2e:	8f 93       	push	r24
 a30:	9f 93       	push	r25
 a32:	ef 93       	push	r30
 a34:	ff 93       	push	r31
 a36:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 a3a:	20 91 c6 00 	lds	r18, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 a3e:	88 71       	andi	r24, 0x18	; 24
 a40:	e0 91 57 02 	lds	r30, 0x0257	; 0x800257 <UART_RxHead>
 a44:	ef 5f       	subi	r30, 0xFF	; 255
 a46:	ef 71       	andi	r30, 0x1F	; 31
 a48:	90 91 56 02 	lds	r25, 0x0256	; 0x800256 <UART_RxTail>
 a4c:	e9 17       	cp	r30, r25
 a4e:	39 f0       	breq	.+14     	; 0xa5e <__vector_25+0x40>
 a50:	e0 93 57 02 	sts	0x0257, r30	; 0x800257 <UART_RxHead>
 a54:	f0 e0       	ldi	r31, 0x00	; 0
 a56:	e6 5a       	subi	r30, 0xA6	; 166
 a58:	fd 4f       	sbci	r31, 0xFD	; 253
 a5a:	20 83       	st	Z, r18
 a5c:	01 c0       	rjmp	.+2      	; 0xa60 <__vector_25+0x42>
 a5e:	82 e0       	ldi	r24, 0x02	; 2
 a60:	80 93 55 02 	sts	0x0255, r24	; 0x800255 <UART_LastRxError>
 a64:	ff 91       	pop	r31
 a66:	ef 91       	pop	r30
 a68:	9f 91       	pop	r25
 a6a:	8f 91       	pop	r24
 a6c:	2f 91       	pop	r18
 a6e:	0f 90       	pop	r0
 a70:	0b be       	out	0x3b, r0	; 59
 a72:	0f 90       	pop	r0
 a74:	0f be       	out	0x3f, r0	; 63
 a76:	0f 90       	pop	r0
 a78:	1f 90       	pop	r1
 a7a:	18 95       	reti

00000a7c <__vector_36>:
 a7c:	1f 92       	push	r1
 a7e:	0f 92       	push	r0
 a80:	0f b6       	in	r0, 0x3f	; 63
 a82:	0f 92       	push	r0
 a84:	11 24       	eor	r1, r1
 a86:	0b b6       	in	r0, 0x3b	; 59
 a88:	0f 92       	push	r0
 a8a:	2f 93       	push	r18
 a8c:	8f 93       	push	r24
 a8e:	9f 93       	push	r25
 a90:	ef 93       	push	r30
 a92:	ff 93       	push	r31
 a94:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
 a98:	20 91 ce 00 	lds	r18, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
 a9c:	88 71       	andi	r24, 0x18	; 24
 a9e:	e0 91 12 02 	lds	r30, 0x0212	; 0x800212 <UART1_RxHead>
 aa2:	ef 5f       	subi	r30, 0xFF	; 255
 aa4:	ef 71       	andi	r30, 0x1F	; 31
 aa6:	90 91 11 02 	lds	r25, 0x0211	; 0x800211 <UART1_RxTail>
 aaa:	e9 17       	cp	r30, r25
 aac:	39 f0       	breq	.+14     	; 0xabc <__vector_36+0x40>
 aae:	e0 93 12 02 	sts	0x0212, r30	; 0x800212 <UART1_RxHead>
 ab2:	f0 e0       	ldi	r31, 0x00	; 0
 ab4:	eb 5e       	subi	r30, 0xEB	; 235
 ab6:	fd 4f       	sbci	r31, 0xFD	; 253
 ab8:	20 83       	st	Z, r18
 aba:	01 c0       	rjmp	.+2      	; 0xabe <__vector_36+0x42>
 abc:	82 e0       	ldi	r24, 0x02	; 2
 abe:	80 93 10 02 	sts	0x0210, r24	; 0x800210 <UART1_LastRxError>
 ac2:	ff 91       	pop	r31
 ac4:	ef 91       	pop	r30
 ac6:	9f 91       	pop	r25
 ac8:	8f 91       	pop	r24
 aca:	2f 91       	pop	r18
 acc:	0f 90       	pop	r0
 ace:	0b be       	out	0x3b, r0	; 59
 ad0:	0f 90       	pop	r0
 ad2:	0f be       	out	0x3f, r0	; 63
 ad4:	0f 90       	pop	r0
 ad6:	1f 90       	pop	r1
 ad8:	18 95       	reti

00000ada <__vector_26>:
 ada:	1f 92       	push	r1
 adc:	0f 92       	push	r0
 ade:	0f b6       	in	r0, 0x3f	; 63
 ae0:	0f 92       	push	r0
 ae2:	11 24       	eor	r1, r1
 ae4:	0b b6       	in	r0, 0x3b	; 59
 ae6:	0f 92       	push	r0
 ae8:	8f 93       	push	r24
 aea:	9f 93       	push	r25
 aec:	ef 93       	push	r30
 aee:	ff 93       	push	r31
 af0:	90 91 59 02 	lds	r25, 0x0259	; 0x800259 <UART_TxHead>
 af4:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <UART_TxTail>
 af8:	98 17       	cp	r25, r24
 afa:	69 f0       	breq	.+26     	; 0xb16 <__vector_26+0x3c>
 afc:	e0 91 58 02 	lds	r30, 0x0258	; 0x800258 <UART_TxTail>
 b00:	ef 5f       	subi	r30, 0xFF	; 255
 b02:	ef 71       	andi	r30, 0x1F	; 31
 b04:	e0 93 58 02 	sts	0x0258, r30	; 0x800258 <UART_TxTail>
 b08:	f0 e0       	ldi	r31, 0x00	; 0
 b0a:	e6 58       	subi	r30, 0x86	; 134
 b0c:	fd 4f       	sbci	r31, 0xFD	; 253
 b0e:	80 81       	ld	r24, Z
 b10:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 b14:	05 c0       	rjmp	.+10     	; 0xb20 <__vector_26+0x46>
 b16:	e1 ec       	ldi	r30, 0xC1	; 193
 b18:	f0 e0       	ldi	r31, 0x00	; 0
 b1a:	80 81       	ld	r24, Z
 b1c:	8f 7d       	andi	r24, 0xDF	; 223
 b1e:	80 83       	st	Z, r24
 b20:	ff 91       	pop	r31
 b22:	ef 91       	pop	r30
 b24:	9f 91       	pop	r25
 b26:	8f 91       	pop	r24
 b28:	0f 90       	pop	r0
 b2a:	0b be       	out	0x3b, r0	; 59
 b2c:	0f 90       	pop	r0
 b2e:	0f be       	out	0x3f, r0	; 63
 b30:	0f 90       	pop	r0
 b32:	1f 90       	pop	r1
 b34:	18 95       	reti

00000b36 <__vector_37>:
 b36:	1f 92       	push	r1
 b38:	0f 92       	push	r0
 b3a:	0f b6       	in	r0, 0x3f	; 63
 b3c:	0f 92       	push	r0
 b3e:	11 24       	eor	r1, r1
 b40:	0b b6       	in	r0, 0x3b	; 59
 b42:	0f 92       	push	r0
 b44:	8f 93       	push	r24
 b46:	9f 93       	push	r25
 b48:	ef 93       	push	r30
 b4a:	ff 93       	push	r31
 b4c:	90 91 14 02 	lds	r25, 0x0214	; 0x800214 <UART1_TxHead>
 b50:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <UART1_TxTail>
 b54:	98 17       	cp	r25, r24
 b56:	69 f0       	breq	.+26     	; 0xb72 <__vector_37+0x3c>
 b58:	e0 91 13 02 	lds	r30, 0x0213	; 0x800213 <UART1_TxTail>
 b5c:	ef 5f       	subi	r30, 0xFF	; 255
 b5e:	ef 71       	andi	r30, 0x1F	; 31
 b60:	e0 93 13 02 	sts	0x0213, r30	; 0x800213 <UART1_TxTail>
 b64:	f0 e0       	ldi	r31, 0x00	; 0
 b66:	eb 5c       	subi	r30, 0xCB	; 203
 b68:	fd 4f       	sbci	r31, 0xFD	; 253
 b6a:	80 81       	ld	r24, Z
 b6c:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
 b70:	05 c0       	rjmp	.+10     	; 0xb7c <__vector_37+0x46>
 b72:	e9 ec       	ldi	r30, 0xC9	; 201
 b74:	f0 e0       	ldi	r31, 0x00	; 0
 b76:	80 81       	ld	r24, Z
 b78:	8f 7d       	andi	r24, 0xDF	; 223
 b7a:	80 83       	st	Z, r24
 b7c:	ff 91       	pop	r31
 b7e:	ef 91       	pop	r30
 b80:	9f 91       	pop	r25
 b82:	8f 91       	pop	r24
 b84:	0f 90       	pop	r0
 b86:	0b be       	out	0x3b, r0	; 59
 b88:	0f 90       	pop	r0
 b8a:	0f be       	out	0x3f, r0	; 63
 b8c:	0f 90       	pop	r0
 b8e:	1f 90       	pop	r1
 b90:	18 95       	reti

00000b92 <uart_init>:
 b92:	10 92 59 02 	sts	0x0259, r1	; 0x800259 <UART_TxHead>
 b96:	10 92 58 02 	sts	0x0258, r1	; 0x800258 <UART_TxTail>
 b9a:	10 92 57 02 	sts	0x0257, r1	; 0x800257 <UART_RxHead>
 b9e:	10 92 56 02 	sts	0x0256, r1	; 0x800256 <UART_RxTail>
 ba2:	e1 e6       	ldi	r30, 0x61	; 97
 ba4:	f0 e0       	ldi	r31, 0x00	; 0
 ba6:	80 e8       	ldi	r24, 0x80	; 128
 ba8:	80 83       	st	Z, r24
 baa:	10 82       	st	Z, r1
 bac:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
 bb0:	87 e6       	ldi	r24, 0x67	; 103
 bb2:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
 bb6:	82 e0       	ldi	r24, 0x02	; 2
 bb8:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 bbc:	88 e1       	ldi	r24, 0x18	; 24
 bbe:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 bc2:	86 e0       	ldi	r24, 0x06	; 6
 bc4:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 bc8:	08 95       	ret

00000bca <uart_putc>:
**************************************************************************/
void uart_putc(unsigned char data)
{	
	unsigned char tmphead;
	
	if (portKey == 0)
 bca:	90 91 9a 02 	lds	r25, 0x029A	; 0x80029a <portKey>
 bce:	91 11       	cpse	r25, r1
 bd0:	15 c0       	rjmp	.+42     	; 0xbfc <uart_putc+0x32>
	{
		tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 bd2:	20 91 59 02 	lds	r18, 0x0259	; 0x800259 <UART_TxHead>
 bd6:	2f 5f       	subi	r18, 0xFF	; 255
 bd8:	2f 71       	andi	r18, 0x1F	; 31
    
		while ( tmphead == UART_TxTail ){
 bda:	90 91 58 02 	lds	r25, 0x0258	; 0x800258 <UART_TxTail>
 bde:	29 17       	cp	r18, r25
 be0:	e1 f3       	breq	.-8      	; 0xbda <uart_putc+0x10>
			;// wait for free space in buffer 
		}
    
		UART_TxBuf[tmphead] = data;
 be2:	e2 2f       	mov	r30, r18
 be4:	f0 e0       	ldi	r31, 0x00	; 0
 be6:	e6 58       	subi	r30, 0x86	; 134
 be8:	fd 4f       	sbci	r31, 0xFD	; 253
 bea:	80 83       	st	Z, r24
		UART_TxHead = tmphead;
 bec:	20 93 59 02 	sts	0x0259, r18	; 0x800259 <UART_TxHead>

		// enable UDRE interrupt 
		UART0_CONTROL |= (1 << UART0_UDRIE);
 bf0:	e1 ec       	ldi	r30, 0xC1	; 193
 bf2:	f0 e0       	ldi	r31, 0x00	; 0
 bf4:	80 81       	ld	r24, Z
 bf6:	80 62       	ori	r24, 0x20	; 32
 bf8:	80 83       	st	Z, r24
 bfa:	08 95       	ret
		
	}
	
	else if (portKey == 1)
 bfc:	91 30       	cpi	r25, 0x01	; 1
 bfe:	a1 f4       	brne	.+40     	; 0xc28 <uart_putc+0x5e>
	{
		tmphead  = (UART1_TxHead + 1) & UART1_TX_BUFFER_MASK;
 c00:	20 91 14 02 	lds	r18, 0x0214	; 0x800214 <UART1_TxHead>
 c04:	2f 5f       	subi	r18, 0xFF	; 255
 c06:	2f 71       	andi	r18, 0x1F	; 31
    
		while ( tmphead == UART1_TxTail ){
 c08:	90 91 13 02 	lds	r25, 0x0213	; 0x800213 <UART1_TxTail>
 c0c:	29 17       	cp	r18, r25
 c0e:	e1 f3       	breq	.-8      	; 0xc08 <uart_putc+0x3e>
			;// wait for free space in buffer 		
		}
		//PORTH &= 251;
    
		UART1_TxBuf[tmphead] = data;
 c10:	e2 2f       	mov	r30, r18
 c12:	f0 e0       	ldi	r31, 0x00	; 0
 c14:	eb 5c       	subi	r30, 0xCB	; 203
 c16:	fd 4f       	sbci	r31, 0xFD	; 253
 c18:	80 83       	st	Z, r24
		UART1_TxHead = tmphead;
 c1a:	20 93 14 02 	sts	0x0214, r18	; 0x800214 <UART1_TxHead>

		// enable UDRE interrupt 
		UART1_CONTROL |= (1 << UART1_UDRIE);	
 c1e:	e9 ec       	ldi	r30, 0xC9	; 201
 c20:	f0 e0       	ldi	r31, 0x00	; 0
 c22:	80 81       	ld	r24, Z
 c24:	80 62       	ori	r24, 0x20	; 32
 c26:	80 83       	st	Z, r24
 c28:	08 95       	ret

00000c2a <memcpy>:
 c2a:	fb 01       	movw	r30, r22
 c2c:	dc 01       	movw	r26, r24
 c2e:	02 c0       	rjmp	.+4      	; 0xc34 <memcpy+0xa>
 c30:	01 90       	ld	r0, Z+
 c32:	0d 92       	st	X+, r0
 c34:	41 50       	subi	r20, 0x01	; 1
 c36:	50 40       	sbci	r21, 0x00	; 0
 c38:	d8 f7       	brcc	.-10     	; 0xc30 <memcpy+0x6>
 c3a:	08 95       	ret

00000c3c <_exit>:
 c3c:	f8 94       	cli

00000c3e <__stop_program>:
 c3e:	ff cf       	rjmp	.-2      	; 0xc3e <__stop_program>
