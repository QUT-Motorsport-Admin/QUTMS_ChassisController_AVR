   1               		.file	"uart10x.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.__vector_25,"ax",@progbits
  12               	.global	__vector_25
  14               	__vector_25:
  15               	.LFB6:
  16               		.file 1 "utils/uart10x.c"
   1:utils/uart10x.c **** /*************************************************************************
   2:utils/uart10x.c **** Title:    Interrupt UART library with receive/transmit circular buffers
   3:utils/uart10x.c **** Author:   Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   4:utils/uart10x.c **** File:     $Id: uart.c,v 1.6.2.1 2007/07/01 11:14:38 peter Exp $
   5:utils/uart10x.c **** Software: AVR-GCC 4.1, AVR Libc 1.4.6 or higher
   6:utils/uart10x.c **** Hardware: any AVR with built-in UART, 
   7:utils/uart10x.c **** License:  GNU General Public License 
   8:utils/uart10x.c ****           
   9:utils/uart10x.c **** DESCRIPTION:
  10:utils/uart10x.c ****     An interrupt is generated when the UART has finished transmitting or
  11:utils/uart10x.c ****     receiving a byte. The interrupt handling routines use circular buffers
  12:utils/uart10x.c ****     for buffering received and transmitted data.
  13:utils/uart10x.c ****     
  14:utils/uart10x.c ****     The UART_RX_BUFFER_SIZE and UART_TX_BUFFER_SIZE variables define
  15:utils/uart10x.c ****     the buffer size in bytes. Note that these variables must be a 
  16:utils/uart10x.c ****     power of 2.
  17:utils/uart10x.c ****     
  18:utils/uart10x.c **** USAGE:
  19:utils/uart10x.c ****     Refere to the header file uart.h for a description of the routines. 
  20:utils/uart10x.c ****     See also example test_uart.c.
  21:utils/uart10x.c **** 
  22:utils/uart10x.c **** NOTES:
  23:utils/uart10x.c ****     Based on Atmel Application Note AVR306
  24:utils/uart10x.c ****                     
  25:utils/uart10x.c **** LICENSE:
  26:utils/uart10x.c ****     Copyright (C) 2006 Peter Fleury
  27:utils/uart10x.c **** 
  28:utils/uart10x.c ****     This program is free software; you can redistribute it and/or modify
  29:utils/uart10x.c ****     it under the terms of the GNU General Public License as published by
  30:utils/uart10x.c ****     the Free Software Foundation; either version 2 of the License, or
  31:utils/uart10x.c ****     any later version.
  32:utils/uart10x.c **** 
  33:utils/uart10x.c ****     This program is distributed in the hope that it will be useful,
  34:utils/uart10x.c ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  35:utils/uart10x.c ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  36:utils/uart10x.c ****     GNU General Public License for more details.
  37:utils/uart10x.c **** 	
  38:utils/uart10x.c **** 
  39:utils/uart10x.c **** MODIFICATIONS:
  40:utils/uart10x.c **** 	Aug 22 2011 - Code added and functions modified for dual serial ports - AK
  41:utils/uart10x.c ****                         
  42:utils/uart10x.c **** *************************************************************************/
  43:utils/uart10x.c **** #include <avr/io.h>
  44:utils/uart10x.c **** #include <avr/interrupt.h>
  45:utils/uart10x.c **** #include <avr/pgmspace.h>
  46:utils/uart10x.c **** //#include <avr/eeprom.h>
  47:utils/uart10x.c **** #include "uart.h"
  48:utils/uart10x.c **** 
  49:utils/uart10x.c **** 
  50:utils/uart10x.c **** 
  51:utils/uart10x.c **** /*
  52:utils/uart10x.c ****  *  constants and macros
  53:utils/uart10x.c ****  */
  54:utils/uart10x.c **** /* size of RX/TX buffers */
  55:utils/uart10x.c **** 
  56:utils/uart10x.c **** 
  57:utils/uart10x.c **** 
  58:utils/uart10x.c **** #define UART_RX_BUFFER_MASK ( UART_RX_BUFFER_SIZE - 1)
  59:utils/uart10x.c **** #define UART_TX_BUFFER_MASK ( UART_TX_BUFFER_SIZE - 1)
  60:utils/uart10x.c **** 
  61:utils/uart10x.c **** #define UART1_RX_BUFFER_MASK ( UART1_RX_BUFFER_SIZE - 1)
  62:utils/uart10x.c **** #define UART1_TX_BUFFER_MASK ( UART1_TX_BUFFER_SIZE - 1)
  63:utils/uart10x.c **** 
  64:utils/uart10x.c **** #if ( UART_RX_BUFFER_SIZE & UART_RX_BUFFER_MASK )
  65:utils/uart10x.c **** #error RX buffer size is not a power of 2
  66:utils/uart10x.c **** #endif
  67:utils/uart10x.c **** #if ( UART_TX_BUFFER_SIZE & UART_TX_BUFFER_MASK )
  68:utils/uart10x.c **** #error TX buffer size is not a power of 2
  69:utils/uart10x.c **** #endif
  70:utils/uart10x.c **** 
  71:utils/uart10x.c **** #if ( UART1_RX_BUFFER_SIZE & UART1_RX_BUFFER_MASK )
  72:utils/uart10x.c **** #error RX1 buffer size is not a power of 2
  73:utils/uart10x.c **** #endif
  74:utils/uart10x.c **** #if ( UART1_TX_BUFFER_SIZE & UART1_TX_BUFFER_MASK )
  75:utils/uart10x.c **** #error TX1 buffer size is not a power of 2
  76:utils/uart10x.c **** #endif
  77:utils/uart10x.c **** 
  78:utils/uart10x.c **** #if defined(__AVR_AT90S2313__) \
  79:utils/uart10x.c ****  || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S4434__) \
  80:utils/uart10x.c ****  || defined(__AVR_AT90S8515__) || defined(__AVR_AT90S8535__) \
  81:utils/uart10x.c ****  || defined(__AVR_ATmega103__)
  82:utils/uart10x.c ****  /* old AVR classic or ATmega103 with one UART */
  83:utils/uart10x.c ****  #define AT90_UART
  84:utils/uart10x.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
  85:utils/uart10x.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
  86:utils/uart10x.c ****  #define UART0_STATUS   USR
  87:utils/uart10x.c ****  #define UART0_CONTROL  UCR
  88:utils/uart10x.c ****  #define UART0_DATA     UDR  
  89:utils/uart10x.c ****  #define UART0_UDRIE    UDRIE
  90:utils/uart10x.c **** #elif defined(__AVR_AT90S2333__) || defined(__AVR_AT90S4433__)
  91:utils/uart10x.c ****  /* old AVR classic with one UART */
  92:utils/uart10x.c ****  #define AT90_UART
  93:utils/uart10x.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
  94:utils/uart10x.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
  95:utils/uart10x.c ****  #define UART0_STATUS   UCSRA
  96:utils/uart10x.c ****  #define UART0_CONTROL  UCSRB
  97:utils/uart10x.c ****  #define UART0_DATA     UDR 
  98:utils/uart10x.c ****  #define UART0_UDRIE    UDRIE
  99:utils/uart10x.c **** #elif  defined(__AVR_ATmega8__)  || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 100:utils/uart10x.c ****   || defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__) \
 101:utils/uart10x.c ****   || defined(__AVR_ATmega323__)
 102:utils/uart10x.c ****   /* ATmega with one USART */
 103:utils/uart10x.c ****  #define ATMEGA_USART
 104:utils/uart10x.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
 105:utils/uart10x.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
 106:utils/uart10x.c ****  #define UART0_STATUS   UCSRA
 107:utils/uart10x.c ****  #define UART0_CONTROL  UCSRB
 108:utils/uart10x.c ****  #define UART0_DATA     UDR
 109:utils/uart10x.c ****  #define UART0_UDRIE    UDRIE
 110:utils/uart10x.c **** #elif defined(__AVR_ATmega163__) 
 111:utils/uart10x.c ****   /* ATmega163 with one UART */
 112:utils/uart10x.c ****  #define ATMEGA_UART
 113:utils/uart10x.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
 114:utils/uart10x.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
 115:utils/uart10x.c ****  #define UART0_STATUS   UCSRA
 116:utils/uart10x.c ****  #define UART0_CONTROL  UCSRB
 117:utils/uart10x.c ****  #define UART0_DATA     UDR
 118:utils/uart10x.c ****  #define UART0_UDRIE    UDRIE
 119:utils/uart10x.c **** #elif defined(__AVR_ATmega162__) 
 120:utils/uart10x.c ****  /* ATmega with two USART */
 121:utils/uart10x.c ****  #define ATMEGA_USART0
 122:utils/uart10x.c ****  #define ATMEGA_USART1
 123:utils/uart10x.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART0_RECV
 124:utils/uart10x.c ****  #define UART1_RECEIVE_INTERRUPT   SIG_USART1_RECV
 125:utils/uart10x.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART0_DATA
 126:utils/uart10x.c ****  #define UART1_TRANSMIT_INTERRUPT  SIG_USART1_DATA
 127:utils/uart10x.c ****  #define UART0_STATUS   UCSR0A
 128:utils/uart10x.c ****  #define UART0_CONTROL  UCSR0B
 129:utils/uart10x.c ****  #define UART0_DATA     UDR0
 130:utils/uart10x.c ****  #define UART0_UDRIE    UDRIE0
 131:utils/uart10x.c ****  #define UART1_STATUS   UCSR1A
 132:utils/uart10x.c ****  #define UART1_CONTROL  UCSR1B
 133:utils/uart10x.c ****  #define UART1_DATA     UDR1
 134:utils/uart10x.c ****  #define UART1_UDRIE    UDRIE1
 135:utils/uart10x.c **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) 
 136:utils/uart10x.c ****  /* ATmega with two USART */
 137:utils/uart10x.c ****  #define ATMEGA_USART0
 138:utils/uart10x.c ****  #define ATMEGA_USART1
 139:utils/uart10x.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART0_RECV
 140:utils/uart10x.c ****  #define UART1_RECEIVE_INTERRUPT   SIG_UART1_RECV
 141:utils/uart10x.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART0_DATA
 142:utils/uart10x.c ****  #define UART1_TRANSMIT_INTERRUPT  SIG_UART1_DATA
 143:utils/uart10x.c ****  #define UART0_STATUS   UCSR0A
 144:utils/uart10x.c ****  #define UART0_CONTROL  UCSR0B
 145:utils/uart10x.c ****  #define UART0_DATA     UDR0
 146:utils/uart10x.c ****  #define UART0_UDRIE    UDRIE0
 147:utils/uart10x.c ****  #define UART1_STATUS   UCSR1A
 148:utils/uart10x.c ****  #define UART1_CONTROL  UCSR1B
 149:utils/uart10x.c ****  #define UART1_DATA     UDR1
 150:utils/uart10x.c ****  #define UART1_UDRIE    UDRIE1
 151:utils/uart10x.c **** #elif defined(__AVR_ATmega161__)
 152:utils/uart10x.c ****  /* ATmega with UART */
 153:utils/uart10x.c ****  #error "AVR ATmega161 currently not supported by this libaray !"
 154:utils/uart10x.c **** #elif defined(__AVR_ATmega169__) 
 155:utils/uart10x.c ****  /* ATmega with one USART */
 156:utils/uart10x.c ****  #define ATMEGA_USART
 157:utils/uart10x.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART_RECV
 158:utils/uart10x.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART_DATA
 159:utils/uart10x.c ****   #define UART0_STATUS   UCSRA
 160:utils/uart10x.c ****  #define UART0_CONTROL  UCSRB
 161:utils/uart10x.c ****  #define UART0_DATA     UDR
 162:utils/uart10x.c ****  #define UART0_UDRIE    UDRIE
 163:utils/uart10x.c **** #elif defined(__AVR_ATmega48__) ||defined(__AVR_ATmega88__) || defined(__AVR_ATmega168__)
 164:utils/uart10x.c ****  /* ATmega with one USART */
 165:utils/uart10x.c ****  #define ATMEGA_USART0
 166:utils/uart10x.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART_RECV
 167:utils/uart10x.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART_DATA
 168:utils/uart10x.c ****  #define UART0_STATUS   UCSR0A
 169:utils/uart10x.c ****  #define UART0_CONTROL  UCSR0B
 170:utils/uart10x.c ****  #define UART0_DATA     UDR0
 171:utils/uart10x.c ****  #define UART0_UDRIE    UDRIE0
 172:utils/uart10x.c **** #elif defined(__AVR_ATtiny2313__)
 173:utils/uart10x.c ****  #define ATMEGA_USART
 174:utils/uart10x.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART0_RX 
 175:utils/uart10x.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART0_UDRE
 176:utils/uart10x.c ****  #define UART0_STATUS   UCSRA
 177:utils/uart10x.c ****  #define UART0_CONTROL  UCSRB
 178:utils/uart10x.c ****  #define UART0_DATA     UDR
 179:utils/uart10x.c ****  #define UART0_UDRIE    UDRIE
 180:utils/uart10x.c **** #elif defined(__AVR_ATmega329__) ||defined(__AVR_ATmega3290__) ||\
 181:utils/uart10x.c ****       defined(__AVR_ATmega649__) ||defined(__AVR_ATmega6490__) ||\
 182:utils/uart10x.c ****       defined(__AVR_ATmega325__) ||defined(__AVR_ATmega3250__) ||\
 183:utils/uart10x.c ****       defined(__AVR_ATmega645__) ||defined(__AVR_ATmega6450__)
 184:utils/uart10x.c ****   /* ATmega with one USART */
 185:utils/uart10x.c ****   #define ATMEGA_USART0
 186:utils/uart10x.c ****   #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
 187:utils/uart10x.c ****   #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
 188:utils/uart10x.c ****   #define UART0_STATUS   UCSR0A
 189:utils/uart10x.c ****   #define UART0_CONTROL  UCSR0B
 190:utils/uart10x.c ****   #define UART0_DATA     UDR0
 191:utils/uart10x.c ****   #define UART0_UDRIE    UDRIE0
 192:utils/uart10x.c **** #elif defined(__AVR_ATmega2560__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega640__) || d
 193:utils/uart10x.c **** /* ATmega with two USART *///  This def is used in GIC fw for 2560. Uarts 0 and 2 in use.
 194:utils/uart10x.c ****   #define ATMEGA_USART0
 195:utils/uart10x.c ****   #define ATMEGA_USART1
 196:utils/uart10x.c ****   #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 197:utils/uart10x.c ****   #define UART1_RECEIVE_INTERRUPT   USART1_RX_vect
 198:utils/uart10x.c ****   #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 199:utils/uart10x.c ****   #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 200:utils/uart10x.c ****   #define UART0_STATUS   UCSR0A
 201:utils/uart10x.c ****   #define UART0_CONTROL  UCSR0B
 202:utils/uart10x.c ****   #define UART0_DATA     UDR0
 203:utils/uart10x.c ****   #define UART0_UDRIE    UDRIE0
 204:utils/uart10x.c ****   #define UART1_STATUS   UCSR1A
 205:utils/uart10x.c ****   #define UART1_CONTROL  UCSR1B
 206:utils/uart10x.c ****   #define UART1_DATA     UDR1
 207:utils/uart10x.c ****   #define UART1_UDRIE    UDRIE1  
 208:utils/uart10x.c **** #elif defined(__AVR_ATmega644__)
 209:utils/uart10x.c ****  /* ATmega with one USART */
 210:utils/uart10x.c ****  #define ATMEGA_USART0
 211:utils/uart10x.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART_RECV
 212:utils/uart10x.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART_DATA
 213:utils/uart10x.c ****  #define UART0_STATUS   UCSR0A
 214:utils/uart10x.c ****  #define UART0_CONTROL  UCSR0B
 215:utils/uart10x.c ****  #define UART0_DATA     UDR0
 216:utils/uart10x.c ****  #define UART0_UDRIE    UDRIE0
 217:utils/uart10x.c **** #elif defined(__AVR_ATmega164P__) || defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__)
 218:utils/uart10x.c ****  /* ATmega with two USART */
 219:utils/uart10x.c ****  #define ATMEGA_USART0
 220:utils/uart10x.c ****  #define ATMEGA_USART1
 221:utils/uart10x.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART_RECV
 222:utils/uart10x.c ****  #define UART1_RECEIVE_INTERRUPT   SIG_USART1_RECV
 223:utils/uart10x.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART_DATA
 224:utils/uart10x.c ****  #define UART1_TRANSMIT_INTERRUPT  SIG_USART1_DATA
 225:utils/uart10x.c ****  #define UART0_STATUS   UCSR0A
 226:utils/uart10x.c ****  #define UART0_CONTROL  UCSR0B
 227:utils/uart10x.c ****  #define UART0_DATA     UDR0
 228:utils/uart10x.c ****  #define UART0_UDRIE    UDRIE0
 229:utils/uart10x.c ****  #define UART1_STATUS   UCSR1A
 230:utils/uart10x.c ****  #define UART1_CONTROL  UCSR1B
 231:utils/uart10x.c ****  #define UART1_DATA     UDR1
 232:utils/uart10x.c ****  #define UART1_UDRIE    UDRIE1
 233:utils/uart10x.c **** #elif defined(__AVR_ATxmega128A1__)
 234:utils/uart10x.c **** /*ATxmegaA3 with 7 USARTS */
 235:utils/uart10x.c ****  #define ATxmega_USART0
 236:utils/uart10x.c ****  #define ATxmega_USART1
 237:utils/uart10x.c ****  #define ATxmega_USART2
 238:utils/uart10x.c ****  #define ATxmega_USART3
 239:utils/uart10x.c ****  #define ATxmega_USART4
 240:utils/uart10x.c ****  #define ATxmega_USART5
 241:utils/uart10x.c ****  #define ATxmega_USART6
 242:utils/uart10x.c **** 
 243:utils/uart10x.c **** #else
 244:utils/uart10x.c ****  #error "no UART definition for MCU available"
 245:utils/uart10x.c **** #endif
 246:utils/uart10x.c **** 
 247:utils/uart10x.c **** 
 248:utils/uart10x.c **** /*
 249:utils/uart10x.c ****  *  module global variables
 250:utils/uart10x.c ****  */
 251:utils/uart10x.c **** static volatile unsigned char UART_TxBuf[UART_TX_BUFFER_SIZE];
 252:utils/uart10x.c **** static volatile unsigned char UART_RxBuf[UART_RX_BUFFER_SIZE];
 253:utils/uart10x.c **** static volatile unsigned char UART_TxHead;
 254:utils/uart10x.c **** static volatile unsigned char UART_TxTail;
 255:utils/uart10x.c **** static volatile unsigned char UART_RxHead;
 256:utils/uart10x.c **** static volatile unsigned char UART_RxTail;
 257:utils/uart10x.c **** static volatile unsigned char UART_LastRxError;
 258:utils/uart10x.c **** 
 259:utils/uart10x.c **** #if defined( ATMEGA_USART1 )
 260:utils/uart10x.c **** static volatile unsigned char UART1_TxBuf[UART_TX_BUFFER_SIZE];
 261:utils/uart10x.c **** static volatile unsigned char UART1_RxBuf[UART_RX_BUFFER_SIZE];
 262:utils/uart10x.c **** static volatile unsigned char UART1_TxHead;
 263:utils/uart10x.c **** static volatile unsigned char UART1_TxTail;
 264:utils/uart10x.c **** static volatile unsigned char UART1_RxHead;
 265:utils/uart10x.c **** static volatile unsigned char UART1_RxTail;
 266:utils/uart10x.c **** static volatile unsigned char UART1_LastRxError;
 267:utils/uart10x.c **** #endif
 268:utils/uart10x.c **** 
 269:utils/uart10x.c **** 
 270:utils/uart10x.c **** 
 271:utils/uart10x.c **** SIGNAL(UART0_RECEIVE_INTERRUPT)
 272:utils/uart10x.c **** //************************************************************************
 273:utils/uart10x.c **** //Function: UART Receive Complete interrupt
 274:utils/uart10x.c **** //Purpose:  called when the UART has received a character
 275:utils/uart10x.c **** //************************************************************************
 276:utils/uart10x.c **** {
  17               		.loc 1 276 0
  18               		.cfi_startproc
  19 0000 1F92      		push r1
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 1, -2
  23 0002 0F92      		push r0
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 0, -3
  27 0004 0FB6      		in r0,__SREG__
  28 0006 0F92      		push r0
  29 0008 1124      		clr __zero_reg__
  30 000a 0BB6      		in r0,__RAMPZ__
  31 000c 0F92      		push r0
  32 000e 2F93      		push r18
  33               	.LCFI2:
  34               		.cfi_def_cfa_offset 5
  35               		.cfi_offset 18, -4
  36 0010 8F93      		push r24
  37               	.LCFI3:
  38               		.cfi_def_cfa_offset 6
  39               		.cfi_offset 24, -5
  40 0012 9F93      		push r25
  41               	.LCFI4:
  42               		.cfi_def_cfa_offset 7
  43               		.cfi_offset 25, -6
  44 0014 EF93      		push r30
  45               	.LCFI5:
  46               		.cfi_def_cfa_offset 8
  47               		.cfi_offset 30, -7
  48 0016 FF93      		push r31
  49               	.LCFI6:
  50               		.cfi_def_cfa_offset 9
  51               		.cfi_offset 31, -8
  52               	/* prologue: Signal */
  53               	/* frame size = 0 */
  54               	/* stack size = 9 */
  55               	.L__stack_usage = 9
 277:utils/uart10x.c ****     unsigned char tmphead;
 278:utils/uart10x.c ****     unsigned char data;
 279:utils/uart10x.c ****     unsigned char usr;
 280:utils/uart10x.c ****     unsigned char lastRxError;
 281:utils/uart10x.c **** 
 282:utils/uart10x.c **** 		
 283:utils/uart10x.c ****  
 284:utils/uart10x.c ****     // read UART status register and UART data register
 285:utils/uart10x.c ****     usr  = UART0_STATUS;
  56               		.loc 1 285 0
  57 0018 8091 C000 		lds r24,192
  58               	.LVL0:
 286:utils/uart10x.c ****     data = UART0_DATA;
  59               		.loc 1 286 0
  60 001c 9091 C600 		lds r25,198
  61               	.LVL1:
 287:utils/uart10x.c ****     
 288:utils/uart10x.c ****  
 289:utils/uart10x.c **** #if defined( AT90_UART )
 290:utils/uart10x.c ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 291:utils/uart10x.c **** #elif defined( ATMEGA_USART )
 292:utils/uart10x.c ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 293:utils/uart10x.c **** #elif defined( ATMEGA_USART0 )
 294:utils/uart10x.c ****     lastRxError = (usr & (_BV(FE0)|_BV(DOR0)) );
 295:utils/uart10x.c **** #elif defined ( ATMEGA_UART )
 296:utils/uart10x.c ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 297:utils/uart10x.c **** #endif
 298:utils/uart10x.c ****         
 299:utils/uart10x.c ****     // calculate buffer index 
 300:utils/uart10x.c ****     tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
  62               		.loc 1 300 0
  63 0020 E091 0000 		lds r30,UART_RxHead
  64 0024 EF5F      		subi r30,lo8(-(1))
  65 0026 EF71      		andi r30,lo8(31)
  66               	.LVL2:
 301:utils/uart10x.c ****     
 302:utils/uart10x.c ****     if ( tmphead == UART_RxTail ) {
  67               		.loc 1 302 0
  68 0028 2091 0000 		lds r18,UART_RxTail
  69 002c 2E17      		cp r18,r30
  70 002e 01F0      		breq .L3
 294:utils/uart10x.c **** #elif defined ( ATMEGA_UART )
  71               		.loc 1 294 0
  72 0030 8871      		andi r24,lo8(24)
  73               	.LVL3:
 303:utils/uart10x.c ****         // error: receive buffer overflow 
 304:utils/uart10x.c ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 305:utils/uart10x.c ****     }else{
 306:utils/uart10x.c ****         // store new index 
 307:utils/uart10x.c ****         UART_RxHead = tmphead;
  74               		.loc 1 307 0
  75 0032 E093 0000 		sts UART_RxHead,r30
 308:utils/uart10x.c ****         // store received data in buffer 
 309:utils/uart10x.c ****        UART_RxBuf[tmphead] = data;
  76               		.loc 1 309 0
  77 0036 F0E0      		ldi r31,0
  78 0038 E050      		subi r30,lo8(-(UART_RxBuf))
  79 003a F040      		sbci r31,hi8(-(UART_RxBuf))
  80               	.LVL4:
  81 003c 9083      		st Z,r25
  82               	.LVL5:
  83               	.L2:
 310:utils/uart10x.c ****     }
 311:utils/uart10x.c ****     UART_LastRxError = lastRxError;   
  84               		.loc 1 311 0
  85 003e 8093 0000 		sts UART_LastRxError,r24
  86               	/* epilogue start */
 312:utils/uart10x.c **** 	
 313:utils/uart10x.c **** }
  87               		.loc 1 313 0
  88 0042 FF91      		pop r31
  89 0044 EF91      		pop r30
  90 0046 9F91      		pop r25
  91               	.LVL6:
  92 0048 8F91      		pop r24
  93               	.LVL7:
  94 004a 2F91      		pop r18
  95 004c 0F90      		pop r0
  96 004e 0BBE      		out __RAMPZ__,r0
  97               	.LVL8:
  98 0050 0F90      		pop r0
  99 0052 0FBE      		out __SREG__,r0
 100 0054 0F90      		pop r0
 101 0056 1F90      		pop r1
 102 0058 1895      		reti
 103               	.LVL9:
 104               	.L3:
 304:utils/uart10x.c ****     }else{
 105               		.loc 1 304 0
 106 005a 82E0      		ldi r24,lo8(2)
 107               	.LVL10:
 108 005c 00C0      		rjmp .L2
 109               		.cfi_endproc
 110               	.LFE6:
 112               		.section	.text.__vector_36,"ax",@progbits
 113               	.global	__vector_36
 115               	__vector_36:
 116               	.LFB7:
 314:utils/uart10x.c **** 
 315:utils/uart10x.c **** SIGNAL(UART1_RECEIVE_INTERRUPT)
 316:utils/uart10x.c **** //************************************************************************
 317:utils/uart10x.c **** //Function: UART Receive Complete interrupt
 318:utils/uart10x.c **** //Purpose:  called when the UART has received a character
 319:utils/uart10x.c **** //************************************************************************
 320:utils/uart10x.c **** {
 117               		.loc 1 320 0
 118               		.cfi_startproc
 119 0000 1F92      		push r1
 120               	.LCFI7:
 121               		.cfi_def_cfa_offset 3
 122               		.cfi_offset 1, -2
 123 0002 0F92      		push r0
 124               	.LCFI8:
 125               		.cfi_def_cfa_offset 4
 126               		.cfi_offset 0, -3
 127 0004 0FB6      		in r0,__SREG__
 128 0006 0F92      		push r0
 129 0008 1124      		clr __zero_reg__
 130 000a 0BB6      		in r0,__RAMPZ__
 131 000c 0F92      		push r0
 132 000e 2F93      		push r18
 133               	.LCFI9:
 134               		.cfi_def_cfa_offset 5
 135               		.cfi_offset 18, -4
 136 0010 8F93      		push r24
 137               	.LCFI10:
 138               		.cfi_def_cfa_offset 6
 139               		.cfi_offset 24, -5
 140 0012 9F93      		push r25
 141               	.LCFI11:
 142               		.cfi_def_cfa_offset 7
 143               		.cfi_offset 25, -6
 144 0014 EF93      		push r30
 145               	.LCFI12:
 146               		.cfi_def_cfa_offset 8
 147               		.cfi_offset 30, -7
 148 0016 FF93      		push r31
 149               	.LCFI13:
 150               		.cfi_def_cfa_offset 9
 151               		.cfi_offset 31, -8
 152               	/* prologue: Signal */
 153               	/* frame size = 0 */
 154               	/* stack size = 9 */
 155               	.L__stack_usage = 9
 321:utils/uart10x.c ****     unsigned char tmphead1;
 322:utils/uart10x.c ****     unsigned char data1;
 323:utils/uart10x.c ****     unsigned char usr1;
 324:utils/uart10x.c ****     unsigned char lastRxError1;
 325:utils/uart10x.c **** 
 326:utils/uart10x.c **** 		
 327:utils/uart10x.c ****  
 328:utils/uart10x.c ****     // read UART status register and UART data register
 329:utils/uart10x.c ****     usr1  = UART1_STATUS;
 156               		.loc 1 329 0
 157 0018 8091 C800 		lds r24,200
 158               	.LVL11:
 330:utils/uart10x.c ****     data1 = UART1_DATA;
 159               		.loc 1 330 0
 160 001c 9091 CE00 		lds r25,206
 161               	.LVL12:
 331:utils/uart10x.c ****     
 332:utils/uart10x.c ****  
 333:utils/uart10x.c **** #if defined( AT90_UART )
 334:utils/uart10x.c ****     lastRxError1 = (usr1 & (_BV(FE)|_BV(DOR)) );
 335:utils/uart10x.c **** #elif defined( ATMEGA_USART )
 336:utils/uart10x.c ****     lastRxError1 = (usr1 & (_BV(FE)|_BV(DOR)) );
 337:utils/uart10x.c **** #elif defined( ATMEGA_USART0 )
 338:utils/uart10x.c ****     lastRxError1 = (usr1 & (_BV(FE0)|_BV(DOR0)) );
 339:utils/uart10x.c **** #elif defined ( ATMEGA_UART )
 340:utils/uart10x.c ****     lastRxError1 = (usr1 & (_BV(FE)|_BV(DOR)) );
 341:utils/uart10x.c **** #endif
 342:utils/uart10x.c ****         
 343:utils/uart10x.c ****     // calculate buffer index 
 344:utils/uart10x.c ****     tmphead1 = ( UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
 162               		.loc 1 344 0
 163 0020 E091 0000 		lds r30,UART1_RxHead
 164 0024 EF5F      		subi r30,lo8(-(1))
 165 0026 EF71      		andi r30,lo8(31)
 166               	.LVL13:
 345:utils/uart10x.c ****     
 346:utils/uart10x.c ****     if ( tmphead1 == UART1_RxTail ) {
 167               		.loc 1 346 0
 168 0028 2091 0000 		lds r18,UART1_RxTail
 169 002c 2E17      		cp r18,r30
 170 002e 01F0      		breq .L6
 338:utils/uart10x.c **** #elif defined ( ATMEGA_UART )
 171               		.loc 1 338 0
 172 0030 8871      		andi r24,lo8(24)
 173               	.LVL14:
 347:utils/uart10x.c ****         // error: receive buffer overflow 
 348:utils/uart10x.c ****         lastRxError1 = UART_BUFFER_OVERFLOW >> 8;
 349:utils/uart10x.c ****     }else{
 350:utils/uart10x.c ****         // store new index 
 351:utils/uart10x.c ****         UART1_RxHead = tmphead1;
 174               		.loc 1 351 0
 175 0032 E093 0000 		sts UART1_RxHead,r30
 352:utils/uart10x.c ****         // store received data in buffer 
 353:utils/uart10x.c ****        UART1_RxBuf[tmphead1] = data1;
 176               		.loc 1 353 0
 177 0036 F0E0      		ldi r31,0
 178 0038 E050      		subi r30,lo8(-(UART1_RxBuf))
 179 003a F040      		sbci r31,hi8(-(UART1_RxBuf))
 180               	.LVL15:
 181 003c 9083      		st Z,r25
 182               	.LVL16:
 183               	.L5:
 354:utils/uart10x.c ****     }
 355:utils/uart10x.c ****     UART1_LastRxError = lastRxError1;   
 184               		.loc 1 355 0
 185 003e 8093 0000 		sts UART1_LastRxError,r24
 186               	/* epilogue start */
 356:utils/uart10x.c **** 	
 357:utils/uart10x.c **** }
 187               		.loc 1 357 0
 188 0042 FF91      		pop r31
 189 0044 EF91      		pop r30
 190 0046 9F91      		pop r25
 191               	.LVL17:
 192 0048 8F91      		pop r24
 193               	.LVL18:
 194 004a 2F91      		pop r18
 195 004c 0F90      		pop r0
 196 004e 0BBE      		out __RAMPZ__,r0
 197               	.LVL19:
 198 0050 0F90      		pop r0
 199 0052 0FBE      		out __SREG__,r0
 200 0054 0F90      		pop r0
 201 0056 1F90      		pop r1
 202 0058 1895      		reti
 203               	.LVL20:
 204               	.L6:
 348:utils/uart10x.c ****     }else{
 205               		.loc 1 348 0
 206 005a 82E0      		ldi r24,lo8(2)
 207               	.LVL21:
 208 005c 00C0      		rjmp .L5
 209               		.cfi_endproc
 210               	.LFE7:
 212               		.section	.text.__vector_26,"ax",@progbits
 213               	.global	__vector_26
 215               	__vector_26:
 216               	.LFB8:
 358:utils/uart10x.c **** 
 359:utils/uart10x.c **** 
 360:utils/uart10x.c **** SIGNAL(UART0_TRANSMIT_INTERRUPT)
 361:utils/uart10x.c **** /*************************************************************************
 362:utils/uart10x.c **** Function: UART Data Register Empty interrupt
 363:utils/uart10x.c **** Purpose:  called when the UART is ready to transmit the next byte
 364:utils/uart10x.c **** **************************************************************************/
 365:utils/uart10x.c **** {
 217               		.loc 1 365 0
 218               		.cfi_startproc
 219 0000 1F92      		push r1
 220               	.LCFI14:
 221               		.cfi_def_cfa_offset 3
 222               		.cfi_offset 1, -2
 223 0002 0F92      		push r0
 224               	.LCFI15:
 225               		.cfi_def_cfa_offset 4
 226               		.cfi_offset 0, -3
 227 0004 0FB6      		in r0,__SREG__
 228 0006 0F92      		push r0
 229 0008 1124      		clr __zero_reg__
 230 000a 0BB6      		in r0,__RAMPZ__
 231 000c 0F92      		push r0
 232 000e 8F93      		push r24
 233               	.LCFI16:
 234               		.cfi_def_cfa_offset 5
 235               		.cfi_offset 24, -4
 236 0010 9F93      		push r25
 237               	.LCFI17:
 238               		.cfi_def_cfa_offset 6
 239               		.cfi_offset 25, -5
 240 0012 EF93      		push r30
 241               	.LCFI18:
 242               		.cfi_def_cfa_offset 7
 243               		.cfi_offset 30, -6
 244 0014 FF93      		push r31
 245               	.LCFI19:
 246               		.cfi_def_cfa_offset 8
 247               		.cfi_offset 31, -7
 248               	/* prologue: Signal */
 249               	/* frame size = 0 */
 250               	/* stack size = 8 */
 251               	.L__stack_usage = 8
 366:utils/uart10x.c ****     unsigned char tmptail;
 367:utils/uart10x.c **** 
 368:utils/uart10x.c ****     
 369:utils/uart10x.c ****     if ( UART_TxHead != UART_TxTail) {
 252               		.loc 1 369 0
 253 0016 9091 0000 		lds r25,UART_TxHead
 254 001a 8091 0000 		lds r24,UART_TxTail
 255 001e 9817      		cp r25,r24
 256 0020 01F0      		breq .L8
 370:utils/uart10x.c ****         /* calculate and store new buffer index */
 371:utils/uart10x.c ****         tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 257               		.loc 1 371 0
 258 0022 E091 0000 		lds r30,UART_TxTail
 259 0026 EF5F      		subi r30,lo8(-(1))
 260 0028 EF71      		andi r30,lo8(31)
 261               	.LVL22:
 372:utils/uart10x.c ****         UART_TxTail = tmptail;
 262               		.loc 1 372 0
 263 002a E093 0000 		sts UART_TxTail,r30
 373:utils/uart10x.c ****         /* get one byte from buffer and write it to UART */
 374:utils/uart10x.c ****         UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 264               		.loc 1 374 0
 265 002e F0E0      		ldi r31,0
 266 0030 E050      		subi r30,lo8(-(UART_TxBuf))
 267 0032 F040      		sbci r31,hi8(-(UART_TxBuf))
 268               	.LVL23:
 269 0034 8081      		ld r24,Z
 270 0036 8093 C600 		sts 198,r24
 271               	.LVL24:
 272               	.L7:
 273               	/* epilogue start */
 375:utils/uart10x.c ****     }else{
 376:utils/uart10x.c ****         /* tx buffer empty, disable UDRE interrupt */
 377:utils/uart10x.c ****         UART0_CONTROL &= ~(1 << UART0_UDRIE);
 378:utils/uart10x.c ****     }
 379:utils/uart10x.c **** }
 274               		.loc 1 379 0
 275 003a FF91      		pop r31
 276 003c EF91      		pop r30
 277 003e 9F91      		pop r25
 278 0040 8F91      		pop r24
 279 0042 0F90      		pop r0
 280 0044 0BBE      		out __RAMPZ__,r0
 281 0046 0F90      		pop r0
 282 0048 0FBE      		out __SREG__,r0
 283 004a 0F90      		pop r0
 284 004c 1F90      		pop r1
 285 004e 1895      		reti
 286               	.L8:
 377:utils/uart10x.c ****     }
 287               		.loc 1 377 0
 288 0050 8091 C100 		lds r24,193
 289 0054 8F7D      		andi r24,lo8(-33)
 290 0056 8093 C100 		sts 193,r24
 291               		.loc 1 379 0
 292 005a 00C0      		rjmp .L7
 293               		.cfi_endproc
 294               	.LFE8:
 296               		.section	.text.__vector_37,"ax",@progbits
 297               	.global	__vector_37
 299               	__vector_37:
 300               	.LFB9:
 380:utils/uart10x.c **** 
 381:utils/uart10x.c **** SIGNAL(UART1_TRANSMIT_INTERRUPT)
 382:utils/uart10x.c **** /*************************************************************************
 383:utils/uart10x.c **** Function: UART1 Data Register Empty interrupt
 384:utils/uart10x.c **** Purpose:  called when the UART1 is ready to transmit the next byte
 385:utils/uart10x.c **** **************************************************************************/
 386:utils/uart10x.c **** {
 301               		.loc 1 386 0
 302               		.cfi_startproc
 303 0000 1F92      		push r1
 304               	.LCFI20:
 305               		.cfi_def_cfa_offset 3
 306               		.cfi_offset 1, -2
 307 0002 0F92      		push r0
 308               	.LCFI21:
 309               		.cfi_def_cfa_offset 4
 310               		.cfi_offset 0, -3
 311 0004 0FB6      		in r0,__SREG__
 312 0006 0F92      		push r0
 313 0008 1124      		clr __zero_reg__
 314 000a 0BB6      		in r0,__RAMPZ__
 315 000c 0F92      		push r0
 316 000e 8F93      		push r24
 317               	.LCFI22:
 318               		.cfi_def_cfa_offset 5
 319               		.cfi_offset 24, -4
 320 0010 9F93      		push r25
 321               	.LCFI23:
 322               		.cfi_def_cfa_offset 6
 323               		.cfi_offset 25, -5
 324 0012 EF93      		push r30
 325               	.LCFI24:
 326               		.cfi_def_cfa_offset 7
 327               		.cfi_offset 30, -6
 328 0014 FF93      		push r31
 329               	.LCFI25:
 330               		.cfi_def_cfa_offset 8
 331               		.cfi_offset 31, -7
 332               	/* prologue: Signal */
 333               	/* frame size = 0 */
 334               	/* stack size = 8 */
 335               	.L__stack_usage = 8
 387:utils/uart10x.c ****     unsigned char tmptail1;
 388:utils/uart10x.c **** 
 389:utils/uart10x.c ****     
 390:utils/uart10x.c ****     if ( UART1_TxHead != UART1_TxTail) {
 336               		.loc 1 390 0
 337 0016 9091 0000 		lds r25,UART1_TxHead
 338 001a 8091 0000 		lds r24,UART1_TxTail
 339 001e 9817      		cp r25,r24
 340 0020 01F0      		breq .L11
 391:utils/uart10x.c ****         /* calculate and store new buffer index */
 392:utils/uart10x.c ****         tmptail1 = (UART1_TxTail + 1) & UART1_TX_BUFFER_MASK;
 341               		.loc 1 392 0
 342 0022 E091 0000 		lds r30,UART1_TxTail
 343 0026 EF5F      		subi r30,lo8(-(1))
 344 0028 EF71      		andi r30,lo8(31)
 345               	.LVL25:
 393:utils/uart10x.c ****         UART1_TxTail = tmptail1;
 346               		.loc 1 393 0
 347 002a E093 0000 		sts UART1_TxTail,r30
 394:utils/uart10x.c ****         /* get one byte from buffer and write it to UART */
 395:utils/uart10x.c ****         UART1_DATA = UART1_TxBuf[tmptail1];  /* start transmission */
 348               		.loc 1 395 0
 349 002e F0E0      		ldi r31,0
 350 0030 E050      		subi r30,lo8(-(UART1_TxBuf))
 351 0032 F040      		sbci r31,hi8(-(UART1_TxBuf))
 352               	.LVL26:
 353 0034 8081      		ld r24,Z
 354 0036 8093 CE00 		sts 206,r24
 355               	.LVL27:
 356               	.L10:
 357               	/* epilogue start */
 396:utils/uart10x.c ****     }else{
 397:utils/uart10x.c ****         /* tx buffer empty, disable UDRE interrupt */
 398:utils/uart10x.c ****         UART1_CONTROL &= ~(1 << UART1_UDRIE);
 399:utils/uart10x.c ****     }
 400:utils/uart10x.c **** }
 358               		.loc 1 400 0
 359 003a FF91      		pop r31
 360 003c EF91      		pop r30
 361 003e 9F91      		pop r25
 362 0040 8F91      		pop r24
 363 0042 0F90      		pop r0
 364 0044 0BBE      		out __RAMPZ__,r0
 365 0046 0F90      		pop r0
 366 0048 0FBE      		out __SREG__,r0
 367 004a 0F90      		pop r0
 368 004c 1F90      		pop r1
 369 004e 1895      		reti
 370               	.L11:
 398:utils/uart10x.c ****     }
 371               		.loc 1 398 0
 372 0050 8091 C900 		lds r24,201
 373 0054 8F7D      		andi r24,lo8(-33)
 374 0056 8093 C900 		sts 201,r24
 375               		.loc 1 400 0
 376 005a 00C0      		rjmp .L10
 377               		.cfi_endproc
 378               	.LFE9:
 380               		.section	.text.uart_init,"ax",@progbits
 381               	.global	uart_init
 383               	uart_init:
 384               	.LFB10:
 401:utils/uart10x.c **** 
 402:utils/uart10x.c **** /*************************************************************************
 403:utils/uart10x.c **** Function: uart_init()
 404:utils/uart10x.c **** Purpose:  initialize UART and set baudrate
 405:utils/uart10x.c **** Input:    baudrate using macro UART_BAUD_SELECT()
 406:utils/uart10x.c **** Returns:  none
 407:utils/uart10x.c **** **************************************************************************/
 408:utils/uart10x.c **** void uart_init(unsigned int baudrate)
 409:utils/uart10x.c **** {
 385               		.loc 1 409 0
 386               		.cfi_startproc
 387               	.LVL28:
 388               	/* prologue: function */
 389               	/* frame size = 0 */
 390               	/* stack size = 0 */
 391               	.L__stack_usage = 0
 410:utils/uart10x.c ****     UART_TxHead = 0;
 392               		.loc 1 410 0
 393 0000 1092 0000 		sts UART_TxHead,__zero_reg__
 411:utils/uart10x.c ****     UART_TxTail = 0;
 394               		.loc 1 411 0
 395 0004 1092 0000 		sts UART_TxTail,__zero_reg__
 412:utils/uart10x.c ****     UART_RxHead = 0;
 396               		.loc 1 412 0
 397 0008 1092 0000 		sts UART_RxHead,__zero_reg__
 413:utils/uart10x.c ****     UART_RxTail = 0;
 398               		.loc 1 413 0
 399 000c 1092 0000 		sts UART_RxTail,__zero_reg__
 414:utils/uart10x.c ****     
 415:utils/uart10x.c **** 	CLKPR = (1<<CLKPCE);  	//enable clock prescaler change
 400               		.loc 1 415 0
 401 0010 E1E6      		ldi r30,lo8(97)
 402 0012 F0E0      		ldi r31,0
 403 0014 80E8      		ldi r24,lo8(-128)
 404               	.LVL29:
 405 0016 8083      		st Z,r24
 416:utils/uart10x.c **** 	CLKPR = 0x00;			//clock divide = 1  so  16MHz/1 = 16MHz
 406               		.loc 1 416 0
 407 0018 1082      		st Z,__zero_reg__
 417:utils/uart10x.c **** 
 418:utils/uart10x.c ****   	UBRR0H = 0;
 408               		.loc 1 418 0
 409 001a 1092 C500 		sts 197,__zero_reg__
 419:utils/uart10x.c ****     UBRR0L = 103;	//19200 baud for laptop/LCD info panel
 410               		.loc 1 419 0
 411 001e 87E6      		ldi r24,lo8(103)
 412 0020 8093 C400 		sts 196,r24
 420:utils/uart10x.c **** 
 421:utils/uart10x.c ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 422:utils/uart10x.c **** 	UCSR0A = 2;		//2x on
 413               		.loc 1 422 0
 414 0024 82E0      		ldi r24,lo8(2)
 415 0026 8093 C000 		sts 192,r24
 423:utils/uart10x.c **** 	UCSR0B = 24;	//tx and rx on  AND rxie on for testing
 416               		.loc 1 423 0
 417 002a 88E1      		ldi r24,lo8(24)
 418 002c 8093 C100 		sts 193,r24
 424:utils/uart10x.c ****     UCSR0C = 6;		//8 - 1 - N
 419               		.loc 1 424 0
 420 0030 86E0      		ldi r24,lo8(6)
 421 0032 8093 C200 		sts 194,r24
 422               	/* epilogue start */
 425:utils/uart10x.c **** 
 426:utils/uart10x.c **** }/* uart_init */
 423               		.loc 1 426 0
 424 0036 0895      		ret
 425               		.cfi_endproc
 426               	.LFE10:
 428               		.section	.text.uart1_init,"ax",@progbits
 429               	.global	uart1_init
 431               	uart1_init:
 432               	.LFB11:
 427:utils/uart10x.c **** 
 428:utils/uart10x.c **** void uart1_init(unsigned int baudrate)
 429:utils/uart10x.c **** {
 433               		.loc 1 429 0
 434               		.cfi_startproc
 435               	.LVL30:
 436               	/* prologue: function */
 437               	/* frame size = 0 */
 438               	/* stack size = 0 */
 439               	.L__stack_usage = 0
 430:utils/uart10x.c **** 	UART1_TxHead = 0;
 440               		.loc 1 430 0
 441 0000 1092 0000 		sts UART1_TxHead,__zero_reg__
 431:utils/uart10x.c ****     UART1_TxTail = 0;
 442               		.loc 1 431 0
 443 0004 1092 0000 		sts UART1_TxTail,__zero_reg__
 432:utils/uart10x.c ****     UART1_RxHead = 0;
 444               		.loc 1 432 0
 445 0008 1092 0000 		sts UART1_RxHead,__zero_reg__
 433:utils/uart10x.c ****     UART1_RxTail = 0;
 446               		.loc 1 433 0
 447 000c 1092 0000 		sts UART1_RxTail,__zero_reg__
 434:utils/uart10x.c **** 	
 435:utils/uart10x.c **** 	CLKPR = (1<<CLKPCE);  	//enable clock prescaler change
 448               		.loc 1 435 0
 449 0010 E1E6      		ldi r30,lo8(97)
 450 0012 F0E0      		ldi r31,0
 451 0014 80E8      		ldi r24,lo8(-128)
 452               	.LVL31:
 453 0016 8083      		st Z,r24
 436:utils/uart10x.c **** 	CLKPR = 0x00;			//clock divide = 1  so  16MHz/1 = 16MHz
 454               		.loc 1 436 0
 455 0018 1082      		st Z,__zero_reg__
 437:utils/uart10x.c **** 	
 438:utils/uart10x.c **** 	UBRR1H = 0;
 456               		.loc 1 438 0
 457 001a 1092 CD00 		sts 205,__zero_reg__
 439:utils/uart10x.c ****     UBRR1L = 103;	// now 250k for CAN  19200 for testing    //9600 baud for gsm modem (207 with 2x 
 458               		.loc 1 439 0
 459 001e 87E6      		ldi r24,lo8(103)
 460 0020 8093 CC00 		sts 204,r24
 440:utils/uart10x.c ****     
 441:utils/uart10x.c ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 442:utils/uart10x.c **** 	UCSR1A = 2;		//2x on
 461               		.loc 1 442 0
 462 0024 82E0      		ldi r24,lo8(2)
 463 0026 8093 C800 		sts 200,r24
 443:utils/uart10x.c **** 	UCSR1B = 24;	//tx and rx on AND rxie on
 464               		.loc 1 443 0
 465 002a 88E1      		ldi r24,lo8(24)
 466 002c 8093 C900 		sts 201,r24
 444:utils/uart10x.c ****     UCSR1C = 6;		//8 - 1 - N
 467               		.loc 1 444 0
 468 0030 86E0      		ldi r24,lo8(6)
 469 0032 8093 CA00 		sts 202,r24
 470               	/* epilogue start */
 445:utils/uart10x.c **** 
 446:utils/uart10x.c **** }/* uart1_init */
 471               		.loc 1 446 0
 472 0036 0895      		ret
 473               		.cfi_endproc
 474               	.LFE11:
 476               		.section	.text.uart_getc,"ax",@progbits
 477               	.global	uart_getc
 479               	uart_getc:
 480               	.LFB12:
 447:utils/uart10x.c **** 
 448:utils/uart10x.c **** 
 449:utils/uart10x.c **** /*************************************************************************
 450:utils/uart10x.c **** Function: uart_getc()
 451:utils/uart10x.c **** Purpose:  return byte from ringbuffer  
 452:utils/uart10x.c **** Returns:  lower byte:  received byte from ringbuffer
 453:utils/uart10x.c ****           higher byte: last receive error
 454:utils/uart10x.c **** **************************************************************************/
 455:utils/uart10x.c **** unsigned int uart_getc(void)
 456:utils/uart10x.c **** {    
 481               		.loc 1 456 0
 482               		.cfi_startproc
 483               	/* prologue: function */
 484               	/* frame size = 0 */
 485               	/* stack size = 0 */
 486               	.L__stack_usage = 0
 457:utils/uart10x.c ****     unsigned char tmptail;
 458:utils/uart10x.c ****     unsigned char data;
 459:utils/uart10x.c **** 
 460:utils/uart10x.c **** 
 461:utils/uart10x.c ****     if ( UART_RxHead == UART_RxTail ) {
 487               		.loc 1 461 0
 488 0000 9091 0000 		lds r25,UART_RxHead
 489 0004 8091 0000 		lds r24,UART_RxTail
 490 0008 9817      		cp r25,r24
 491 000a 01F0      		breq .L17
 462:utils/uart10x.c ****         return UART_NO_DATA;   /* no data available */
 463:utils/uart10x.c ****     }
 464:utils/uart10x.c ****     
 465:utils/uart10x.c ****     /* calculate /store buffer index */
 466:utils/uart10x.c ****     tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 492               		.loc 1 466 0
 493 000c E091 0000 		lds r30,UART_RxTail
 494 0010 EF5F      		subi r30,lo8(-(1))
 495 0012 EF71      		andi r30,lo8(31)
 496               	.LVL32:
 467:utils/uart10x.c ****     UART_RxTail = tmptail; 
 497               		.loc 1 467 0
 498 0014 E093 0000 		sts UART_RxTail,r30
 468:utils/uart10x.c ****     
 469:utils/uart10x.c ****     /* get data from receive buffer */
 470:utils/uart10x.c ****     data = UART_RxBuf[tmptail];
 499               		.loc 1 470 0
 500 0018 F0E0      		ldi r31,0
 501 001a E050      		subi r30,lo8(-(UART_RxBuf))
 502 001c F040      		sbci r31,hi8(-(UART_RxBuf))
 503               	.LVL33:
 504 001e 2081      		ld r18,Z
 505               	.LVL34:
 471:utils/uart10x.c ****     
 472:utils/uart10x.c ****     return (UART_LastRxError << 8) + data;
 506               		.loc 1 472 0
 507 0020 9091 0000 		lds r25,UART_LastRxError
 508 0024 892F      		mov r24,r25
 509 0026 90E0      		ldi r25,0
 510 0028 982F      		mov r25,r24
 511 002a 8827      		clr r24
 512 002c 820F      		add r24,r18
 513 002e 911D      		adc r25,__zero_reg__
 514 0030 0895      		ret
 515               	.LVL35:
 516               	.L17:
 462:utils/uart10x.c ****     }
 517               		.loc 1 462 0
 518 0032 80E0      		ldi r24,0
 519 0034 91E0      		ldi r25,lo8(1)
 520               	/* epilogue start */
 473:utils/uart10x.c **** 
 474:utils/uart10x.c **** }/* uart_getc */
 521               		.loc 1 474 0
 522 0036 0895      		ret
 523               		.cfi_endproc
 524               	.LFE12:
 526               		.section	.text.uart1_getc,"ax",@progbits
 527               	.global	uart1_getc
 529               	uart1_getc:
 530               	.LFB13:
 475:utils/uart10x.c **** 
 476:utils/uart10x.c **** unsigned int uart1_getc(void)
 477:utils/uart10x.c **** {    
 531               		.loc 1 477 0
 532               		.cfi_startproc
 533               	/* prologue: function */
 534               	/* frame size = 0 */
 535               	/* stack size = 0 */
 536               	.L__stack_usage = 0
 478:utils/uart10x.c ****     unsigned char tmptail1;
 479:utils/uart10x.c ****     unsigned char data1;
 480:utils/uart10x.c **** 
 481:utils/uart10x.c **** 
 482:utils/uart10x.c ****     if ( UART1_RxHead == UART1_RxTail ) {
 537               		.loc 1 482 0
 538 0000 9091 0000 		lds r25,UART1_RxHead
 539 0004 8091 0000 		lds r24,UART1_RxTail
 540 0008 9817      		cp r25,r24
 541 000a 01F0      		breq .L20
 483:utils/uart10x.c ****         return UART_NO_DATA;   /* no data available */
 484:utils/uart10x.c ****     }
 485:utils/uart10x.c ****     
 486:utils/uart10x.c ****     /* calculate /store buffer index */
 487:utils/uart10x.c ****     tmptail1 = (UART1_RxTail + 1) & UART1_RX_BUFFER_MASK;
 542               		.loc 1 487 0
 543 000c E091 0000 		lds r30,UART1_RxTail
 544 0010 EF5F      		subi r30,lo8(-(1))
 545 0012 EF71      		andi r30,lo8(31)
 546               	.LVL36:
 488:utils/uart10x.c ****     UART1_RxTail = tmptail1; 
 547               		.loc 1 488 0
 548 0014 E093 0000 		sts UART1_RxTail,r30
 489:utils/uart10x.c ****     
 490:utils/uart10x.c ****     /* get data from receive buffer */
 491:utils/uart10x.c ****     data1 = UART1_RxBuf[tmptail1];
 549               		.loc 1 491 0
 550 0018 F0E0      		ldi r31,0
 551 001a E050      		subi r30,lo8(-(UART1_RxBuf))
 552 001c F040      		sbci r31,hi8(-(UART1_RxBuf))
 553               	.LVL37:
 554 001e 2081      		ld r18,Z
 555               	.LVL38:
 492:utils/uart10x.c ****     
 493:utils/uart10x.c ****     return (UART1_LastRxError << 8) + data1;
 556               		.loc 1 493 0
 557 0020 9091 0000 		lds r25,UART1_LastRxError
 558 0024 892F      		mov r24,r25
 559 0026 90E0      		ldi r25,0
 560 0028 982F      		mov r25,r24
 561 002a 8827      		clr r24
 562 002c 820F      		add r24,r18
 563 002e 911D      		adc r25,__zero_reg__
 564 0030 0895      		ret
 565               	.LVL39:
 566               	.L20:
 483:utils/uart10x.c ****     }
 567               		.loc 1 483 0
 568 0032 80E0      		ldi r24,0
 569 0034 91E0      		ldi r25,lo8(1)
 570               	/* epilogue start */
 494:utils/uart10x.c **** 
 495:utils/uart10x.c **** }/* uart1_getc */
 571               		.loc 1 495 0
 572 0036 0895      		ret
 573               		.cfi_endproc
 574               	.LFE13:
 576               		.section	.text.uart_putc,"ax",@progbits
 577               	.global	uart_putc
 579               	uart_putc:
 580               	.LFB14:
 496:utils/uart10x.c **** 
 497:utils/uart10x.c **** 
 498:utils/uart10x.c **** /*************************************************************************
 499:utils/uart10x.c **** Function: uart_putc()
 500:utils/uart10x.c **** Purpose:  write byte to ringbuffer for transmitting via UART, choosing the
 501:utils/uart10x.c **** 		  correct port to write to based on current traffic flow
 502:utils/uart10x.c **** Input:    byte to be transmitted
 503:utils/uart10x.c **** Returns:  none          
 504:utils/uart10x.c **** **************************************************************************/
 505:utils/uart10x.c **** void uart_putc(unsigned char data)
 506:utils/uart10x.c **** {	
 581               		.loc 1 506 0
 582               		.cfi_startproc
 583               	.LVL40:
 584               	/* prologue: function */
 585               	/* frame size = 0 */
 586               	/* stack size = 0 */
 587               	.L__stack_usage = 0
 507:utils/uart10x.c **** 	unsigned char tmphead;
 508:utils/uart10x.c **** 	
 509:utils/uart10x.c **** 	if (portKey == 0)
 588               		.loc 1 509 0
 589 0000 9091 0000 		lds r25,portKey
 590 0004 9111      		cpse r25,__zero_reg__
 591 0006 00C0      		rjmp .L22
 510:utils/uart10x.c **** 	{
 511:utils/uart10x.c **** 		tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 592               		.loc 1 511 0
 593 0008 9091 0000 		lds r25,UART_TxHead
 594 000c 9F5F      		subi r25,lo8(-(1))
 595 000e 9F71      		andi r25,lo8(31)
 596               	.LVL41:
 597               	.L23:
 512:utils/uart10x.c ****     
 513:utils/uart10x.c **** 		while ( tmphead == UART_TxTail ){
 598               		.loc 1 513 0 discriminator 1
 599 0010 2091 0000 		lds r18,UART_TxTail
 600 0014 2917      		cp r18,r25
 601 0016 01F0      		breq .L23
 514:utils/uart10x.c **** 			;// wait for free space in buffer 
 515:utils/uart10x.c **** 		}
 516:utils/uart10x.c ****     
 517:utils/uart10x.c **** 		UART_TxBuf[tmphead] = data;
 602               		.loc 1 517 0
 603 0018 E92F      		mov r30,r25
 604 001a F0E0      		ldi r31,0
 605 001c E050      		subi r30,lo8(-(UART_TxBuf))
 606 001e F040      		sbci r31,hi8(-(UART_TxBuf))
 607 0020 8083      		st Z,r24
 518:utils/uart10x.c **** 		UART_TxHead = tmphead;
 608               		.loc 1 518 0
 609 0022 9093 0000 		sts UART_TxHead,r25
 519:utils/uart10x.c **** 
 520:utils/uart10x.c **** 		// enable UDRE interrupt 
 521:utils/uart10x.c **** 		UART0_CONTROL |= (1 << UART0_UDRIE);
 610               		.loc 1 521 0
 611 0026 8091 C100 		lds r24,193
 612               	.LVL42:
 613 002a 8062      		ori r24,lo8(32)
 614 002c 8093 C100 		sts 193,r24
 615 0030 0895      		ret
 616               	.LVL43:
 617               	.L22:
 522:utils/uart10x.c **** 		
 523:utils/uart10x.c **** 	}
 524:utils/uart10x.c **** 	
 525:utils/uart10x.c **** 	else if (portKey == 1)
 618               		.loc 1 525 0
 619 0032 9130      		cpi r25,lo8(1)
 620 0034 01F4      		brne .L21
 621               	.LVL44:
 622               	.LBB4:
 623               	.LBB5:
 526:utils/uart10x.c **** 	{
 527:utils/uart10x.c **** 		tmphead  = (UART1_TxHead + 1) & UART1_TX_BUFFER_MASK;
 624               		.loc 1 527 0
 625 0036 9091 0000 		lds r25,UART1_TxHead
 626 003a 9F5F      		subi r25,lo8(-(1))
 627 003c 9F71      		andi r25,lo8(31)
 628               	.LVL45:
 629               	.L25:
 528:utils/uart10x.c ****     
 529:utils/uart10x.c **** 		while ( tmphead == UART1_TxTail ){
 630               		.loc 1 529 0
 631 003e 2091 0000 		lds r18,UART1_TxTail
 632 0042 9217      		cp r25,r18
 633 0044 01F0      		breq .L25
 530:utils/uart10x.c **** 			;// wait for free space in buffer 		
 531:utils/uart10x.c **** 		}
 532:utils/uart10x.c **** 		//PORTH &= 251;
 533:utils/uart10x.c ****     
 534:utils/uart10x.c **** 		UART1_TxBuf[tmphead] = data;
 634               		.loc 1 534 0
 635 0046 E92F      		mov r30,r25
 636 0048 F0E0      		ldi r31,0
 637 004a E050      		subi r30,lo8(-(UART1_TxBuf))
 638 004c F040      		sbci r31,hi8(-(UART1_TxBuf))
 639 004e 8083      		st Z,r24
 535:utils/uart10x.c **** 		UART1_TxHead = tmphead;
 640               		.loc 1 535 0
 641 0050 9093 0000 		sts UART1_TxHead,r25
 536:utils/uart10x.c **** 
 537:utils/uart10x.c **** 		// enable UDRE interrupt 
 538:utils/uart10x.c **** 		UART1_CONTROL |= (1 << UART1_UDRIE);	
 642               		.loc 1 538 0
 643 0054 8091 C900 		lds r24,201
 644               	.LVL46:
 645 0058 8062      		ori r24,lo8(32)
 646 005a 8093 C900 		sts 201,r24
 647               	.LVL47:
 648               	.L21:
 649               	/* epilogue start */
 650               	.LBE5:
 651               	.LBE4:
 539:utils/uart10x.c **** 	}		
 540:utils/uart10x.c **** 	
 541:utils/uart10x.c **** }/* uart_putc */
 652               		.loc 1 541 0
 653 005e 0895      		ret
 654               		.cfi_endproc
 655               	.LFE14:
 657               		.section	.text.uart1_putc,"ax",@progbits
 658               	.global	uart1_putc
 660               	uart1_putc:
 661               	.LFB15:
 542:utils/uart10x.c **** 
 543:utils/uart10x.c **** void uart1_putc(unsigned char data1)
 544:utils/uart10x.c **** {
 662               		.loc 1 544 0
 663               		.cfi_startproc
 664               	.LVL48:
 665               	/* prologue: function */
 666               	/* frame size = 0 */
 667               	/* stack size = 0 */
 668               	.L__stack_usage = 0
 545:utils/uart10x.c **** 	
 546:utils/uart10x.c **** 	unsigned char tmphead;
 547:utils/uart10x.c **** 	tmphead  = (UART1_TxHead + 1) & UART1_TX_BUFFER_MASK;
 669               		.loc 1 547 0
 670 0000 9091 0000 		lds r25,UART1_TxHead
 671 0004 9F5F      		subi r25,lo8(-(1))
 672 0006 9F71      		andi r25,lo8(31)
 673               	.LVL49:
 674               	.L29:
 548:utils/uart10x.c ****     
 549:utils/uart10x.c **** 		while ( tmphead == UART1_TxTail ){
 675               		.loc 1 549 0 discriminator 1
 676 0008 2091 0000 		lds r18,UART1_TxTail
 677 000c 2917      		cp r18,r25
 678 000e 01F0      		breq .L29
 550:utils/uart10x.c **** 			;// wait for free space in buffer 		
 551:utils/uart10x.c **** 		}
 552:utils/uart10x.c **** 		//PORTH &= 251;
 553:utils/uart10x.c ****     
 554:utils/uart10x.c **** 		UART1_TxBuf[tmphead] = data1;
 679               		.loc 1 554 0
 680 0010 E92F      		mov r30,r25
 681 0012 F0E0      		ldi r31,0
 682 0014 E050      		subi r30,lo8(-(UART1_TxBuf))
 683 0016 F040      		sbci r31,hi8(-(UART1_TxBuf))
 684 0018 8083      		st Z,r24
 555:utils/uart10x.c **** 		UART1_TxHead = tmphead;
 685               		.loc 1 555 0
 686 001a 9093 0000 		sts UART1_TxHead,r25
 556:utils/uart10x.c **** 
 557:utils/uart10x.c **** 		// enable UDRE interrupt 
 558:utils/uart10x.c **** 		UART1_CONTROL |= (1 << UART1_UDRIE);	
 687               		.loc 1 558 0
 688 001e 8091 C900 		lds r24,201
 689               	.LVL50:
 690 0022 8062      		ori r24,lo8(32)
 691 0024 8093 C900 		sts 201,r24
 692               	/* epilogue start */
 559:utils/uart10x.c **** 	    	
 560:utils/uart10x.c **** }/* uart1_putc */
 693               		.loc 1 560 0
 694 0028 0895      		ret
 695               		.cfi_endproc
 696               	.LFE15:
 698               		.section	.text.uart_puts,"ax",@progbits
 699               	.global	uart_puts
 701               	uart_puts:
 702               	.LFB16:
 561:utils/uart10x.c **** 
 562:utils/uart10x.c **** 
 563:utils/uart10x.c **** /*************************************************************************
 564:utils/uart10x.c **** Function: uart_puts()
 565:utils/uart10x.c **** Purpose:  transmit string to UART
 566:utils/uart10x.c **** Input:    string to be transmitted
 567:utils/uart10x.c **** Returns:  none          
 568:utils/uart10x.c **** **************************************************************************/
 569:utils/uart10x.c **** void uart_puts(const char *s )
 570:utils/uart10x.c **** {
 703               		.loc 1 570 0
 704               		.cfi_startproc
 705               	.LVL51:
 706 0000 CF93      		push r28
 707               	.LCFI26:
 708               		.cfi_def_cfa_offset 3
 709               		.cfi_offset 28, -2
 710 0002 DF93      		push r29
 711               	.LCFI27:
 712               		.cfi_def_cfa_offset 4
 713               		.cfi_offset 29, -3
 714               	/* prologue: function */
 715               	/* frame size = 0 */
 716               	/* stack size = 2 */
 717               	.L__stack_usage = 2
 718 0004 EC01      		movw r28,r24
 719               	.LVL52:
 720               	.L32:
 571:utils/uart10x.c ****     while (*s) 
 721               		.loc 1 571 0
 722 0006 8991      		ld r24,Y+
 723               	.LVL53:
 724 0008 8111      		cpse r24,__zero_reg__
 725 000a 00C0      		rjmp .L33
 726               	/* epilogue start */
 572:utils/uart10x.c ****       uart_putc(*s++);
 573:utils/uart10x.c **** 
 574:utils/uart10x.c **** }/* uart_puts */
 727               		.loc 1 574 0
 728 000c DF91      		pop r29
 729 000e CF91      		pop r28
 730               	.LVL54:
 731 0010 0895      		ret
 732               	.LVL55:
 733               	.L33:
 572:utils/uart10x.c ****       uart_putc(*s++);
 734               		.loc 1 572 0
 735 0012 0E94 0000 		call uart_putc
 736               	.LVL56:
 737 0016 00C0      		rjmp .L32
 738               		.cfi_endproc
 739               	.LFE16:
 741               		.section	.text.uart1_puts,"ax",@progbits
 742               	.global	uart1_puts
 744               	uart1_puts:
 745               	.LFB17:
 575:utils/uart10x.c **** 
 576:utils/uart10x.c **** void uart1_puts(const char *t )
 577:utils/uart10x.c **** {
 746               		.loc 1 577 0
 747               		.cfi_startproc
 748               	.LVL57:
 749 0000 CF93      		push r28
 750               	.LCFI28:
 751               		.cfi_def_cfa_offset 3
 752               		.cfi_offset 28, -2
 753 0002 DF93      		push r29
 754               	.LCFI29:
 755               		.cfi_def_cfa_offset 4
 756               		.cfi_offset 29, -3
 757               	/* prologue: function */
 758               	/* frame size = 0 */
 759               	/* stack size = 2 */
 760               	.L__stack_usage = 2
 761 0004 EC01      		movw r28,r24
 762               	.LVL58:
 763               	.L35:
 578:utils/uart10x.c ****     while (*t) 
 764               		.loc 1 578 0
 765 0006 8991      		ld r24,Y+
 766               	.LVL59:
 767 0008 8111      		cpse r24,__zero_reg__
 768 000a 00C0      		rjmp .L36
 769               	/* epilogue start */
 579:utils/uart10x.c ****       uart1_putc(*t++);
 580:utils/uart10x.c **** 
 581:utils/uart10x.c **** }/* uart1_puts */
 770               		.loc 1 581 0
 771 000c DF91      		pop r29
 772 000e CF91      		pop r28
 773               	.LVL60:
 774 0010 0895      		ret
 775               	.LVL61:
 776               	.L36:
 579:utils/uart10x.c ****       uart1_putc(*t++);
 777               		.loc 1 579 0
 778 0012 0E94 0000 		call uart1_putc
 779               	.LVL62:
 780 0016 00C0      		rjmp .L35
 781               		.cfi_endproc
 782               	.LFE17:
 784               		.section	.text.uart_puts_p,"ax",@progbits
 785               	.global	uart_puts_p
 787               	uart_puts_p:
 788               	.LFB18:
 582:utils/uart10x.c **** 
 583:utils/uart10x.c **** 
 584:utils/uart10x.c **** /*************************************************************************
 585:utils/uart10x.c **** Function: uart_puts_p()
 586:utils/uart10x.c **** Purpose:  transmit string from program memory to UART
 587:utils/uart10x.c **** Input:    program memory string to be transmitted
 588:utils/uart10x.c **** Returns:  none
 589:utils/uart10x.c **** **************************************************************************/
 590:utils/uart10x.c **** void uart_puts_p(const char *progmem_s )
 591:utils/uart10x.c **** {
 789               		.loc 1 591 0
 790               		.cfi_startproc
 791               	.LVL63:
 792 0000 CF93      		push r28
 793               	.LCFI30:
 794               		.cfi_def_cfa_offset 3
 795               		.cfi_offset 28, -2
 796 0002 DF93      		push r29
 797               	.LCFI31:
 798               		.cfi_def_cfa_offset 4
 799               		.cfi_offset 29, -3
 800               	/* prologue: function */
 801               	/* frame size = 0 */
 802               	/* stack size = 2 */
 803               	.L__stack_usage = 2
 804 0004 EC01      		movw r28,r24
 805               	.LVL64:
 806               	.L38:
 807               	.LBB6:
 592:utils/uart10x.c ****     register char c;
 593:utils/uart10x.c ****     
 594:utils/uart10x.c ****     while ( (c = pgm_read_byte(progmem_s++)) ) 
 808               		.loc 1 594 0
 809 0006 FE01      		movw r30,r28
 810               	/* #APP */
 811               	 ;  594 "utils/uart10x.c" 1
 812 0008 8491      		lpm r24, Z
 813               		
 814               	 ;  0 "" 2
 815               	.LVL65:
 816               	/* #NOAPP */
 817 000a 2196      		adiw r28,1
 818               	.LVL66:
 819               	.LBE6:
 820 000c 8111      		cpse r24,__zero_reg__
 821 000e 00C0      		rjmp .L39
 822               	/* epilogue start */
 595:utils/uart10x.c ****       uart_putc(c);
 596:utils/uart10x.c **** 
 597:utils/uart10x.c **** }/* uart_puts_p */
 823               		.loc 1 597 0
 824 0010 DF91      		pop r29
 825 0012 CF91      		pop r28
 826               	.LVL67:
 827 0014 0895      		ret
 828               	.LVL68:
 829               	.L39:
 595:utils/uart10x.c ****       uart_putc(c);
 830               		.loc 1 595 0
 831 0016 0E94 0000 		call uart_putc
 832               	.LVL69:
 833 001a 00C0      		rjmp .L38
 834               		.cfi_endproc
 835               	.LFE18:
 837               		.section	.text.uart1_puts_p,"ax",@progbits
 838               	.global	uart1_puts_p
 840               	uart1_puts_p:
 841               	.LFB19:
 598:utils/uart10x.c **** 
 599:utils/uart10x.c **** void uart1_puts_p(const char *progmem_t )
 600:utils/uart10x.c **** {
 842               		.loc 1 600 0
 843               		.cfi_startproc
 844               	.LVL70:
 845 0000 CF93      		push r28
 846               	.LCFI32:
 847               		.cfi_def_cfa_offset 3
 848               		.cfi_offset 28, -2
 849 0002 DF93      		push r29
 850               	.LCFI33:
 851               		.cfi_def_cfa_offset 4
 852               		.cfi_offset 29, -3
 853               	/* prologue: function */
 854               	/* frame size = 0 */
 855               	/* stack size = 2 */
 856               	.L__stack_usage = 2
 857 0004 EC01      		movw r28,r24
 858               	.LVL71:
 859               	.L41:
 860               	.LBB7:
 601:utils/uart10x.c ****     register char c;
 602:utils/uart10x.c ****     
 603:utils/uart10x.c ****     while ( (c = pgm_read_byte(progmem_t++)) ) 
 861               		.loc 1 603 0
 862 0006 FE01      		movw r30,r28
 863               	/* #APP */
 864               	 ;  603 "utils/uart10x.c" 1
 865 0008 8491      		lpm r24, Z
 866               		
 867               	 ;  0 "" 2
 868               	.LVL72:
 869               	/* #NOAPP */
 870 000a 2196      		adiw r28,1
 871               	.LVL73:
 872               	.LBE7:
 873 000c 8111      		cpse r24,__zero_reg__
 874 000e 00C0      		rjmp .L42
 875               	/* epilogue start */
 604:utils/uart10x.c ****       uart1_putc(c);
 605:utils/uart10x.c **** 
 606:utils/uart10x.c **** }/* uart1_puts_p */
 876               		.loc 1 606 0
 877 0010 DF91      		pop r29
 878 0012 CF91      		pop r28
 879               	.LVL74:
 880 0014 0895      		ret
 881               	.LVL75:
 882               	.L42:
 604:utils/uart10x.c ****       uart1_putc(c);
 883               		.loc 1 604 0
 884 0016 0E94 0000 		call uart1_putc
 885               	.LVL76:
 886 001a 00C0      		rjmp .L41
 887               		.cfi_endproc
 888               	.LFE19:
 890               		.section	.text.isCharAvailable,"ax",@progbits
 891               	.global	isCharAvailable
 893               	isCharAvailable:
 894               	.LFB20:
 607:utils/uart10x.c **** 
 608:utils/uart10x.c **** 
 609:utils/uart10x.c **** // UART polled functions
 610:utils/uart10x.c **** 
 611:utils/uart10x.c **** char isCharAvailable()
 612:utils/uart10x.c **** {	
 895               		.loc 1 612 0
 896               		.cfi_startproc
 897               	/* prologue: function */
 898               	/* frame size = 0 */
 899               	/* stack size = 0 */
 900               	.L__stack_usage = 0
 613:utils/uart10x.c **** 	// Does the RX0 bit of the USART Status and Control Register
 614:utils/uart10x.c **** 	// indicate a char has been received?
 615:utils/uart10x.c **** 	if ( (UCSR0A & (0x80)) ) return 1;
 901               		.loc 1 615 0
 902 0000 8091 C000 		lds r24,192
 616:utils/uart10x.c **** 	else return 0;
 617:utils/uart10x.c **** }
 903               		.loc 1 617 0
 904 0004 881F      		rol r24
 905 0006 8827      		clr r24
 906 0008 881F      		rol r24
 907               	/* epilogue start */
 908 000a 0895      		ret
 909               		.cfi_endproc
 910               	.LFE20:
 912               		.section	.text.isCharAvailable_1,"ax",@progbits
 913               	.global	isCharAvailable_1
 915               	isCharAvailable_1:
 916               	.LFB21:
 618:utils/uart10x.c **** 
 619:utils/uart10x.c **** char isCharAvailable_1()
 620:utils/uart10x.c **** {	
 917               		.loc 1 620 0
 918               		.cfi_startproc
 919               	/* prologue: function */
 920               	/* frame size = 0 */
 921               	/* stack size = 0 */
 922               	.L__stack_usage = 0
 621:utils/uart10x.c **** 	// Does the RX0 bit of the USART Status and Control Register
 622:utils/uart10x.c **** 	// indicate a char has been received?
 623:utils/uart10x.c **** 	if ( (UCSR1A & (0x80)) ) return 1;
 923               		.loc 1 623 0
 924 0000 8091 C800 		lds r24,200
 624:utils/uart10x.c **** 	else return 0;
 625:utils/uart10x.c **** }
 925               		.loc 1 625 0
 926 0004 881F      		rol r24
 927 0006 8827      		clr r24
 928 0008 881F      		rol r24
 929               	/* epilogue start */
 930 000a 0895      		ret
 931               		.cfi_endproc
 932               	.LFE21:
 934               		.section	.text.receiveChar,"ax",@progbits
 935               	.global	receiveChar
 937               	receiveChar:
 938               	.LFB22:
 626:utils/uart10x.c **** 
 627:utils/uart10x.c **** char receiveChar()
 628:utils/uart10x.c **** {
 939               		.loc 1 628 0
 940               		.cfi_startproc
 941               	/* prologue: function */
 942               	/* frame size = 0 */
 943               	/* stack size = 0 */
 944               	.L__stack_usage = 0
 629:utils/uart10x.c **** 	// Return the char in the UDR0 register
 630:utils/uart10x.c **** 	return UDR0;
 945               		.loc 1 630 0
 946 0000 8091 C600 		lds r24,198
 947               	/* epilogue start */
 631:utils/uart10x.c **** 	
 632:utils/uart10x.c **** }
 948               		.loc 1 632 0
 949 0004 0895      		ret
 950               		.cfi_endproc
 951               	.LFE22:
 953               		.section	.text.receiveChar_1,"ax",@progbits
 954               	.global	receiveChar_1
 956               	receiveChar_1:
 957               	.LFB23:
 633:utils/uart10x.c **** 
 634:utils/uart10x.c **** char receiveChar_1()
 635:utils/uart10x.c **** {
 958               		.loc 1 635 0
 959               		.cfi_startproc
 960               	/* prologue: function */
 961               	/* frame size = 0 */
 962               	/* stack size = 0 */
 963               	.L__stack_usage = 0
 636:utils/uart10x.c **** 	// Return the char in the UDR2 register
 637:utils/uart10x.c **** 	return UDR1;
 964               		.loc 1 637 0
 965 0000 8091 CE00 		lds r24,206
 966               	/* epilogue start */
 638:utils/uart10x.c **** 	
 639:utils/uart10x.c **** }...
 967               		.loc 1 639 0
 968 0004 0895      		ret
 969               		.cfi_endproc
 970               	.LFE23:
 972               		.local	UART1_LastRxError
 973               		.comm	UART1_LastRxError,1,1
 974               		.local	UART1_RxTail
 975               		.comm	UART1_RxTail,1,1
 976               		.local	UART1_RxHead
 977               		.comm	UART1_RxHead,1,1
 978               		.local	UART1_TxTail
 979               		.comm	UART1_TxTail,1,1
 980               		.local	UART1_TxHead
 981               		.comm	UART1_TxHead,1,1
 982               		.local	UART1_RxBuf
 983               		.comm	UART1_RxBuf,32,1
 984               		.local	UART1_TxBuf
 985               		.comm	UART1_TxBuf,32,1
 986               		.local	UART_LastRxError
 987               		.comm	UART_LastRxError,1,1
 988               		.local	UART_RxTail
 989               		.comm	UART_RxTail,1,1
 990               		.local	UART_RxHead
 991               		.comm	UART_RxHead,1,1
 992               		.local	UART_TxTail
 993               		.comm	UART_TxTail,1,1
 994               		.local	UART_TxHead
 995               		.comm	UART_TxHead,1,1
 996               		.local	UART_RxBuf
 997               		.comm	UART_RxBuf,32,1
 998               		.local	UART_TxBuf
 999               		.comm	UART_TxBuf,32,1
 1000               		.comm	portKey,1,1
 1001               		.text
 1002               	.Letext0:
 1003               		.file 2 "/usr/local/Cellar/avr-gcc/7.3.0/avr/include/stdint.h"
 1004               		.file 3 "/usr/local/Cellar/avr-gcc/7.3.0/lib/avr-gcc/7/gcc/avr/7.3.0/include/stddef.h"
 1005               		.file 4 "/usr/local/Cellar/avr-gcc/7.3.0/avr/include/stdio.h"
 1006               		.file 5 "/usr/local/Cellar/avr-gcc/7.3.0/avr/include/stdlib.h"
 1007               		.file 6 "utils/uart.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 uart10x.c
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:4      *ABS*:000000000000003f __SREG__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:14     .text.__vector_25:0000000000000000 __vector_25
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:989    .bss:0000000000000047 UART_RxHead
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:987    .bss:0000000000000046 UART_RxTail
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:995    .bss:000000000000004a UART_RxBuf
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:985    .bss:0000000000000045 UART_LastRxError
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:115    .text.__vector_36:0000000000000000 __vector_36
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:975    .bss:0000000000000002 UART1_RxHead
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:973    .bss:0000000000000001 UART1_RxTail
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:981    .bss:0000000000000005 UART1_RxBuf
                             .bss:0000000000000000 UART1_LastRxError
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:215    .text.__vector_26:0000000000000000 __vector_26
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:993    .bss:0000000000000049 UART_TxHead
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:991    .bss:0000000000000048 UART_TxTail
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:997    .bss:000000000000006a UART_TxBuf
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:299    .text.__vector_37:0000000000000000 __vector_37
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:979    .bss:0000000000000004 UART1_TxHead
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:977    .bss:0000000000000003 UART1_TxTail
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:983    .bss:0000000000000025 UART1_TxBuf
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:383    .text.uart_init:0000000000000000 uart_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:431    .text.uart1_init:0000000000000000 uart1_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:479    .text.uart_getc:0000000000000000 uart_getc
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:529    .text.uart1_getc:0000000000000000 uart1_getc
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:579    .text.uart_putc:0000000000000000 uart_putc
                            *COM*:0000000000000001 portKey
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:660    .text.uart1_putc:0000000000000000 uart1_putc
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:701    .text.uart_puts:0000000000000000 uart_puts
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:744    .text.uart1_puts:0000000000000000 uart1_puts
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:787    .text.uart_puts_p:0000000000000000 uart_puts_p
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:840    .text.uart1_puts_p:0000000000000000 uart1_puts_p
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:893    .text.isCharAvailable:0000000000000000 isCharAvailable
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:915    .text.isCharAvailable_1:0000000000000000 isCharAvailable_1
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:937    .text.receiveChar:0000000000000000 receiveChar
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccJldj03.s:956    .text.receiveChar_1:0000000000000000 receiveChar_1

UNDEFINED SYMBOLS
__do_clear_bss
